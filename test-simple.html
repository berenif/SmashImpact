<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Game Test</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        
        #gameCanvas {
            border: 2px solid #fff;
            background: #111;
        }
        
        #status {
            margin-top: 20px;
            padding: 10px;
            background: #333;
            border-radius: 5px;
        }
        
        .entity-info {
            margin: 5px 0;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="status">
        <div class="entity-info">Status: <span id="gameStatus">Initializing...</span></div>
        <div class="entity-info">Player: <span id="playerStatus">None</span></div>
        <div class="entity-info">Enemies: <span id="enemyCount">0</span></div>
        <div class="entity-info">FPS: <span id="fps">0</span></div>
    </div>

    <script type="module">
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Simple JavaScript implementation (no WASM)
        class SimpleGame {
            constructor() {
                this.player = null;
                this.enemies = [];
                this.lastTime = 0;
                this.frameCount = 0;
                this.fpsTime = 0;
                this.fps = 0;
            }
            
            init() {
                // Create player
                this.player = {
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    radius: 20,
                    color: '#00ff00',
                    speed: 200,
                    health: 100
                };
                
                // Create enemies
                for (let i = 0; i < 5; i++) {
                    const angle = (Math.PI * 2 * i) / 5;
                    this.enemies.push({
                        x: canvas.width / 2 + Math.cos(angle) * 200,
                        y: canvas.height / 2 + Math.sin(angle) * 200,
                        radius: 15,
                        color: '#ff0000',
                        speed: 50,
                        health: 50
                    });
                }
                
                document.getElementById('gameStatus').textContent = 'Running';
                document.getElementById('playerStatus').textContent = 'Health: 100';
                document.getElementById('enemyCount').textContent = this.enemies.length;
            }
            
            update(deltaTime) {
                // Simple enemy AI - move towards player
                this.enemies.forEach(enemy => {
                    const dx = this.player.x - enemy.x;
                    const dy = this.player.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        enemy.x += (dx / distance) * enemy.speed * deltaTime;
                        enemy.y += (dy / distance) * enemy.speed * deltaTime;
                    }
                });
                
                // Simple player movement with keyboard
                if (this.keys) {
                    if (this.keys['ArrowUp'] || this.keys['w']) {
                        this.player.y -= this.player.speed * deltaTime;
                    }
                    if (this.keys['ArrowDown'] || this.keys['s']) {
                        this.player.y += this.player.speed * deltaTime;
                    }
                    if (this.keys['ArrowLeft'] || this.keys['a']) {
                        this.player.x -= this.player.speed * deltaTime;
                    }
                    if (this.keys['ArrowRight'] || this.keys['d']) {
                        this.player.x += this.player.speed * deltaTime;
                    }
                }
                
                // Keep player in bounds
                this.player.x = Math.max(this.player.radius, Math.min(canvas.width - this.player.radius, this.player.x));
                this.player.y = Math.max(this.player.radius, Math.min(canvas.height - this.player.radius, this.player.y));
            }
            
            render() {
                // Clear canvas
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw grid
                ctx.strokeStyle = 'rgba(100, 100, 200, 0.2)';
                ctx.lineWidth = 1;
                const gridSize = 50;
                
                for (let x = 0; x <= canvas.width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                for (let y = 0; y <= canvas.height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                // Draw player
                if (this.player) {
                    ctx.fillStyle = this.player.color;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = this.player.color;
                    ctx.beginPath();
                    ctx.arc(this.player.x, this.player.y, this.player.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
                
                // Draw enemies
                this.enemies.forEach(enemy => {
                    ctx.fillStyle = enemy.color;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = enemy.color;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                });
            }
            
            gameLoop(timestamp) {
                // Calculate delta time
                const deltaTime = (timestamp - this.lastTime) / 1000;
                this.lastTime = timestamp;
                
                // Update FPS
                this.frameCount++;
                if (timestamp - this.fpsTime >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.fpsTime = timestamp;
                    document.getElementById('fps').textContent = this.fps;
                }
                
                // Update and render
                if (deltaTime < 0.1) { // Prevent huge jumps
                    this.update(deltaTime);
                }
                this.render();
                
                requestAnimationFrame(this.gameLoop.bind(this));
            }
            
            start() {
                this.init();
                
                // Setup keyboard input
                this.keys = {};
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                });
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });
                
                // Start game loop
                requestAnimationFrame(this.gameLoop.bind(this));
            }
        }
        
        // Try WASM first, fallback to JavaScript
        async function initGame() {
            try {
                // Try loading WASM
                const module = await import('./public/game_engine.js');
                const GameEngineModule = module.default;
                const wasmModule = await GameEngineModule();
                
                // Test if WASM works
                const engine = new wasmModule.GameEngine(800, 600);
                
                // Create player
                const player = engine.createPlayer(400, 300);
                
                // Create enemies
                for (let i = 0; i < 5; i++) {
                    const angle = (Math.PI * 2 * i) / 5;
                    const x = 400 + Math.cos(angle) * 200;
                    const y = 300 + Math.sin(angle) * 200;
                    engine.createEnemy(x, y);
                }
                
                document.getElementById('gameStatus').textContent = 'WASM Running';
                
                // WASM game loop
                function wasmGameLoop(timestamp) {
                    const deltaTime = (timestamp - wasmGameLoop.lastTime || 0) / 1000;
                    wasmGameLoop.lastTime = timestamp;
                    
                    // Update
                    engine.update(deltaTime);
                    
                    // Get entities and render
                    const entities = engine.getAllEntities();
                    
                    // Clear canvas
                    ctx.fillStyle = '#111';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Render entities
                    entities.forEach(entity => {
                        ctx.save();
                        
                        if (entity.type === 'player') {
                            ctx.fillStyle = '#00ff00';
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = '#00ff00';
                        } else if (entity.type === 'enemy') {
                            ctx.fillStyle = '#ff0000';
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = '#ff0000';
                        }
                        
                        ctx.beginPath();
                        ctx.arc(entity.x, entity.y, entity.type === 'player' ? 20 : 15, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    });
                    
                    document.getElementById('enemyCount').textContent = entities.filter(e => e.type === 'enemy').length;
                    
                    requestAnimationFrame(wasmGameLoop);
                }
                
                requestAnimationFrame(wasmGameLoop);
                
            } catch (error) {
                console.error('WASM failed, using JavaScript fallback:', error);
                document.getElementById('gameStatus').textContent = 'JavaScript Fallback';
                
                // Use JavaScript implementation
                const game = new SimpleGame();
                game.start();
            }
        }
        
        // Start the game
        initGame();
    </script>
</body>
</html>