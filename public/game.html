<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#0a0e27">
  <title>Smash Impact - Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      user-select: none;
    }

    :root {
      --primary: #6366f1;
      --secondary: #22d3ee;
      --success: #10b981;
      --danger: #ef4444;
      --warning: #f59e0b;
      --bg-dark: #0a0e27;
      --surface: rgba(26, 31, 58, 0.9);
      --text: #e2e8f0;
      --text-muted: #94a3b8;
      --joystick-size: 120px;
      --joystick-knob: 50px;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-dark);
      color: var(--text);
      overflow: hidden;
      position: fixed;
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    /* Game container */
    .game-container {
      width: 100%;
      height: 100%;
      position: relative;
      display: flex;
      flex-direction: column;
    }

    /* Top HUD */
    .hud-top {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(to bottom, rgba(10, 14, 39, 0.9), transparent);
      padding: env(safe-area-inset-top) 20px 20px;
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .score-display {
      display: flex;
      gap: 20px;
      align-items: center;
    }

    .score-item {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .score-label {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .score-value {
      font-size: 24px;
      font-weight: bold;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .timer {
      background: var(--surface);
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
      backdrop-filter: blur(10px);
    }

    .connection-indicator {
      display: flex;
      align-items: center;
      gap: 6px;
      background: var(--surface);
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 12px;
      backdrop-filter: blur(10px);
    }

    .connection-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--success);
      animation: pulse 2s infinite;
    }

    .connection-dot.disconnected {
      background: var(--danger);
      animation: blink 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.2); }
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    /* Game canvas */
    #gameCanvas {
      flex: 1;
      width: 100%;
      background: radial-gradient(circle at center, #1a1f3a, #0a0e27);
      touch-action: none;
    }

    /* Mobile controls */
    .mobile-controls {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 20px;
      padding-bottom: calc(20px + env(safe-area-inset-bottom));
      pointer-events: none;
      z-index: 200;
    }

    .controls-container {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      max-width: 600px;
      margin: 0 auto;
      width: 100%;
    }

    /* Joystick */
    .joystick-wrapper {
      pointer-events: auto;
      position: relative;
    }

    .joystick {
      width: var(--joystick-size);
      height: var(--joystick-size);
      background: radial-gradient(circle, rgba(99, 102, 241, 0.1), rgba(99, 102, 241, 0.05));
      border: 2px solid rgba(99, 102, 241, 0.3);
      border-radius: 50%;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(10px);
      transition: border-color 0.3s ease;
    }

    .joystick.active {
      border-color: rgba(99, 102, 241, 0.6);
      background: radial-gradient(circle, rgba(99, 102, 241, 0.2), rgba(99, 102, 241, 0.1));
    }

    .joystick-knob {
      width: var(--joystick-knob);
      height: var(--joystick-knob);
      background: linear-gradient(135deg, var(--primary), var(--primary) 50%, var(--secondary));
      border-radius: 50%;
      position: absolute;
      box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
      transition: transform 0.1s ease-out;
      pointer-events: none;
    }

    /* Direction indicators */
    .joystick::before {
      content: '';
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      border-bottom: 6px solid rgba(255, 255, 255, 0.2);
    }

    .joystick::after {
      content: '';
      position: absolute;
      inset: 20px;
      border: 1px dashed rgba(255, 255, 255, 0.1);
      border-radius: 50%;
    }

    /* Action buttons */
    .action-buttons {
      pointer-events: auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
    }

    .action-btn {
      width: 60px;
      height: 60px;
      background: radial-gradient(circle, rgba(34, 211, 238, 0.2), rgba(34, 211, 238, 0.1));
      border: 2px solid rgba(34, 211, 238, 0.4);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      backdrop-filter: blur(10px);
      transition: all 0.2s ease;
      position: relative;
    }

    .action-btn:active {
      transform: scale(0.95);
      background: radial-gradient(circle, rgba(34, 211, 238, 0.4), rgba(34, 211, 238, 0.2));
      border-color: rgba(34, 211, 238, 0.8);
    }

    .action-btn.primary {
      width: 70px;
      height: 70px;
      font-size: 28px;
    }

    .action-btn-label {
      position: absolute;
      bottom: -18px;
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* Desktop controls (hidden on mobile) */
    .desktop-controls {
      display: none;
    }

    /* Pause menu */
    .pause-menu {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      backdrop-filter: blur(10px);
    }

    .pause-menu.active {
      display: flex;
    }

    .pause-content {
      background: var(--surface);
      border-radius: 20px;
      padding: 30px;
      text-align: center;
      max-width: 300px;
      width: 90%;
    }

    .pause-title {
      font-size: 24px;
      margin-bottom: 20px;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .pause-buttons {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .pause-btn {
      padding: 12px 24px;
      background: linear-gradient(135deg, var(--primary), var(--primary));
      border: none;
      border-radius: 10px;
      color: white;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .pause-btn:active {
      transform: scale(0.95);
    }

    .pause-btn.secondary {
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    /* Menu button */
    .menu-btn {
      position: absolute;
      top: env(safe-area-inset-top);
      right: 20px;
      width: 40px;
      height: 40px;
      background: var(--surface);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      z-index: 101;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* Responsive adjustments */
    @media (min-width: 768px) {
      :root {
        --joystick-size: 150px;
        --joystick-knob: 60px;
      }

      .action-btn {
        width: 70px;
        height: 70px;
      }

      .action-btn.primary {
        width: 80px;
        height: 80px;
      }

      .mobile-controls {
        display: none;
      }

      .desktop-controls {
        display: block;
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--surface);
        padding: 10px 20px;
        border-radius: 10px;
        font-size: 12px;
        color: var(--text-muted);
        backdrop-filter: blur(10px);
      }
    }

    /* Landscape mode adjustments */
    @media (orientation: landscape) and (max-height: 500px) {
      .hud-top {
        padding-top: 10px;
        padding-bottom: 10px;
      }

      .score-value {
        font-size: 20px;
      }

      :root {
        --joystick-size: 100px;
        --joystick-knob: 40px;
      }

      .action-btn {
        width: 50px;
        height: 50px;
        font-size: 20px;
      }

      .action-btn.primary {
        width: 60px;
        height: 60px;
        font-size: 24px;
      }
    }

    /* Performance optimizations */
    .joystick-knob,
    .action-btn {
      will-change: transform;
    }

    /* Debug info */
    .debug-info {
      position: absolute;
      top: 100px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 10px;
      display: none;
      z-index: 500;
      max-width: 200px;
    }

    .debug-info.active {
      display: block;
    }
    
    .debug-info div {
      margin: 2px 0;
    }
    
    .debug-legend {
      position: absolute;
      top: 100px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 10px;
      display: none;
      z-index: 500;
      color: #10b981;
    }
    
    .debug-legend.active {
      display: block;
    }
    
    .debug-legend h4 {
      color: #22d3ee;
      margin-bottom: 5px;
      font-size: 11px;
    }
    
    .debug-legend div {
      margin: 2px 0;
    }
    
    .debug-legend .key {
      color: #f59e0b;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <!-- Top HUD -->
    <div class="hud-top">
      <div class="score-display">
        <div class="score-item">
          <span class="score-label">You</span>
          <span class="score-value" id="scoreYou">0</span>
        </div>
        <div class="score-item">
          <span class="score-label">Them</span>
          <span class="score-value" id="scoreThem">0</span>
        </div>
      </div>
      
      <div class="timer" id="gameTimer">00:00</div>
      
      <div class="connection-indicator">
        <span class="connection-dot" id="connectionDot"></span>
        <span id="connectionText">Connected</span>
      </div>
    </div>

    <!-- Menu button -->
    <button class="menu-btn" onclick="togglePause()">‚ò∞</button>

    <!-- Game canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- Mobile controls -->
    <div class="mobile-controls" id="mobileControls">
      <div class="controls-container">
        <!-- Joystick -->
        <div class="joystick-wrapper">
          <div class="joystick" id="joystick">
            <div class="joystick-knob" id="joystickKnob"></div>
          </div>
        </div>

        <!-- Action buttons -->
        <div class="action-buttons">
          <button class="action-btn" id="btnBoost" data-action="boost">
            <span>‚ö°</span>
            <span class="action-btn-label">Boost</span>
          </button>
          <button class="action-btn primary" id="btnAttack" data-action="attack">
            <span>üí•</span>
            <span class="action-btn-label">Attack</span>
          </button>
        </div>
      </div>
    </div>

    <!-- Desktop controls hint -->
    <div class="desktop-controls">
      Use WASD or Arrow Keys to move ‚Ä¢ Space to attack ‚Ä¢ Shift to boost
    </div>

    <!-- Pause menu -->
    <div class="pause-menu" id="pauseMenu">
      <div class="pause-content">
        <h2 class="pause-title">Game Paused</h2>
        <div class="pause-buttons">
          <button class="pause-btn" onclick="resumeGame()">Resume</button>
          <button class="pause-btn secondary" onclick="toggleDebug()">Toggle Debug</button>
          <button class="pause-btn secondary" onclick="exitGame()">Exit to Menu</button>
        </div>
      </div>
    </div>

    <!-- Debug info -->
    <div class="debug-info active" id="debugInfo">
      <div>FPS: <span id="fps">0</span></div>
      <div>Joystick: <span id="joystickDebug">0, 0</span></div>
      <div>Touch: <span id="touchDebug">none</span></div>
      <div>Device: <span id="deviceDebug">-</span></div>
      <div>Wave: <span id="waveDebug">1</span></div>
      <div>Wolves: <span id="wolvesDebug">0</span></div>
      <div>Player Pos: <span id="playerPosDebug">0, 0</span></div>
      <div>Score: <span id="scoreDebug">0 - 0</span></div>
    </div>
    
    <!-- Debug legend -->
    <div class="debug-legend active" id="debugLegend">
      <h4>Debug Controls</h4>
      <div><span class="key">`</span> Toggle Debug</div>
      <div><span class="key">1</span> Spawn Wolf</div>
      <div><span class="key">2</span> Clear Wolves</div>
      <div><span class="key">3</span> Next Wave</div>
      <div><span class="key">4</span> Give Shield</div>
      <div><span class="key">5</span> Spawn Power-up</div>
      <div><span class="key">0</span> Reset Game</div>
      <div><span class="key">ESC</span> Pause Menu</div>
    </div>
  </div>

  <!-- Multiplayer synchronization -->
  <script src="multiplayer.js"></script>
  <!-- Visual effects system -->
  <script src="visual-effects.js"></script>
  
  <script type="module">
    // Mobile joystick controller
    class JoystickController {
      constructor(element, knob) {
        this.element = element;
        this.knob = knob;
        this.active = false;
        this.startPos = { x: 0, y: 0 };
        this.currentPos = { x: 0, y: 0 };
        this.vector = { x: 0, y: 0 };
        
        // Calculate radius after a small delay to ensure elements are rendered
        this.radius = 60; // Default value
        this.knobRadius = 20; // Default value
        this.maxDistance = 40; // Default value
        this.deadZone = 0.15; // 15% dead zone for better control
        this.sensitivity = 1.0; // Sensitivity multiplier
        
        // Store bound event handlers for cleanup
        this.boundHandleStart = this.handleStart.bind(this);
        this.boundHandleMove = this.handleMove.bind(this);
        this.boundHandleEnd = this.handleEnd.bind(this);
        this.boundHandleMouseStart = this.handleMouseStart.bind(this);
        this.boundHandleMouseMove = this.handleMouseMove.bind(this);
        this.boundHandleMouseEnd = this.handleMouseEnd.bind(this);
        
        // Recalculate once element is ready
        requestAnimationFrame(() => {
          if (element && element.offsetWidth) {
            this.radius = element.offsetWidth / 2;
            this.knobRadius = knob ? knob.offsetWidth / 2 : 20;
            this.maxDistance = this.radius - this.knobRadius;
          }
        });
        
        this.init();
      }

      init() {
        // Touch events
        this.element.addEventListener('touchstart', this.boundHandleStart, { passive: false });
        this.element.addEventListener('touchmove', this.boundHandleMove, { passive: false });
        this.element.addEventListener('touchend', this.boundHandleEnd, { passive: false });
        this.element.addEventListener('touchcancel', this.boundHandleEnd, { passive: false });
        
        // Mouse events for testing
        this.element.addEventListener('mousedown', this.boundHandleMouseStart);
        document.addEventListener('mousemove', this.boundHandleMouseMove);
        document.addEventListener('mouseup', this.boundHandleMouseEnd);
      }
      
      destroy() {
        // Remove all event listeners
        this.element.removeEventListener('touchstart', this.boundHandleStart);
        this.element.removeEventListener('touchmove', this.boundHandleMove);
        this.element.removeEventListener('touchend', this.boundHandleEnd);
        this.element.removeEventListener('touchcancel', this.boundHandleEnd);
        this.element.removeEventListener('mousedown', this.boundHandleMouseStart);
        document.removeEventListener('mousemove', this.boundHandleMouseMove);
        document.removeEventListener('mouseup', this.boundHandleMouseEnd);
      }

      handleStart(e) {
        e.preventDefault();
        this.active = true;
        this.element.classList.add('active');
        
        const touch = e.touches[0];
        const rect = this.element.getBoundingClientRect();
        this.startPos = {
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2
        };
        
        this.updatePosition(touch.clientX, touch.clientY);
      }

      handleMove(e) {
        if (!this.active) return;
        e.preventDefault();
        
        const touch = e.touches[0];
        this.updatePosition(touch.clientX, touch.clientY);
      }

      handleEnd(e) {
        e.preventDefault();
        this.active = false;
        this.element.classList.remove('active');
        this.resetPosition();
      }

      handleMouseStart(e) {
        if ('ontouchstart' in window) return; // Ignore mouse on touch devices
        this.active = true;
        this.element.classList.add('active');
        
        const rect = this.element.getBoundingClientRect();
        this.startPos = {
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2
        };
        
        this.updatePosition(e.clientX, e.clientY);
      }

      handleMouseMove(e) {
        if (!this.active || 'ontouchstart' in window) return;
        this.updatePosition(e.clientX, e.clientY);
      }

      handleMouseEnd(e) {
        if ('ontouchstart' in window) return;
        this.active = false;
        this.element.classList.remove('active');
        this.resetPosition();
      }

      updatePosition(x, y) {
        const deltaX = x - this.startPos.x;
        const deltaY = y - this.startPos.y;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        if (distance <= this.maxDistance) {
          this.currentPos = { x: deltaX, y: deltaY };
        } else {
          const angle = Math.atan2(deltaY, deltaX);
          this.currentPos = {
            x: Math.cos(angle) * this.maxDistance,
            y: Math.sin(angle) * this.maxDistance
          };
        }
        
        // Update knob position
        this.knob.style.transform = `translate(${this.currentPos.x}px, ${this.currentPos.y}px)`;
        
        // Calculate normalized vector (-1 to 1)
        this.vector = {
          x: this.currentPos.x / this.maxDistance,
          y: this.currentPos.y / this.maxDistance
        };
        
        // Update debug info
        if (window.debugMode) {
          document.getElementById('joystickDebug').textContent = 
            `${this.vector.x.toFixed(2)}, ${this.vector.y.toFixed(2)}`;
        }
      }

      resetPosition() {
        this.currentPos = { x: 0, y: 0 };
        this.vector = { x: 0, y: 0 };
        this.knob.style.transform = 'translate(0, 0)';
        
        if (window.debugMode) {
          document.getElementById('joystickDebug').textContent = '0, 0';
        }
      }

      getVector() {
        // Apply dead zone
        const magnitude = Math.sqrt(this.vector.x * this.vector.x + this.vector.y * this.vector.y);
        if (magnitude < this.deadZone) {
          return { x: 0, y: 0 };
        }
        
        // Apply sensitivity and remap to remove dead zone gap
        const adjustedMagnitude = (magnitude - this.deadZone) / (1 - this.deadZone);
        const normalizedX = this.vector.x / magnitude;
        const normalizedY = this.vector.y / magnitude;
        
        return {
          x: normalizedX * adjustedMagnitude * this.sensitivity,
          y: normalizedY * adjustedMagnitude * this.sensitivity
        };
      }
    }

    // Action button handler
    class ActionButton {
      constructor(element, action) {
        this.element = element;
        this.action = action;
        this.pressed = false;
        
        // Store bound handlers
        this.boundHandlePress = this.handlePress.bind(this);
        this.boundHandleRelease = this.handleRelease.bind(this);
        
        this.init();
      }

      init() {
        // Touch events
        this.element.addEventListener('touchstart', this.boundHandlePress, { passive: false });
        this.element.addEventListener('touchend', this.boundHandleRelease, { passive: false });
        this.element.addEventListener('touchcancel', this.boundHandleRelease, { passive: false });
        
        // Mouse events
        this.element.addEventListener('mousedown', this.boundHandlePress);
        this.element.addEventListener('mouseup', this.boundHandleRelease);
        this.element.addEventListener('mouseleave', this.boundHandleRelease);
      }
      
      destroy() {
        // Remove all event listeners
        this.element.removeEventListener('touchstart', this.boundHandlePress);
        this.element.removeEventListener('touchend', this.boundHandleRelease);
        this.element.removeEventListener('touchcancel', this.boundHandleRelease);
        this.element.removeEventListener('mousedown', this.boundHandlePress);
        this.element.removeEventListener('mouseup', this.boundHandleRelease);
        this.element.removeEventListener('mouseleave', this.boundHandleRelease);
      }

      handlePress(e) {
        e.preventDefault();
        this.pressed = true;
        this.element.classList.add('pressed');
        
        // Trigger action
        if (window.gameInstance) {
          window.gameInstance.handleAction(this.action, true);
        }
        
        // Haptic feedback on mobile
        if ('vibrate' in navigator) {
          navigator.vibrate(10);
        }
      }

      handleRelease(e) {
        e.preventDefault();
        this.pressed = false;
        this.element.classList.remove('pressed');
        
        // Stop action
        if (window.gameInstance) {
          window.gameInstance.handleAction(this.action, false);
        }
      }

      isPressed() {
        return this.pressed;
      }
    }

    // Game class
    class MobileGame {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        
        // Check if context was successfully created
        if (!this.ctx) {
          console.error('Failed to get 2D context from canvas');
          alert('Failed to initialize game canvas. Please refresh the page.');
          return;
        }
        
        this.running = false;
        this.paused = false;
        
        // Initialize visual effects with error handling
        try {
          this.vfx = new window.VisualEffects(canvas, this.ctx);
        } catch (error) {
          console.error('Failed to initialize visual effects:', error);
          this.vfx = null; // Continue without visual effects
        }
        
        // Check for multiplayer
        this.isMultiplayer = sessionStorage.getItem('p2pConnected') === 'true';
        this.multiplayer = null;
        
        if (this.isMultiplayer) {
          // Initialize multiplayer synchronization
          this.multiplayer = new window.MultiplayerGame();
          this.setupMultiplayer();
        }
        
        // Game state (will be overridden by multiplayer if connected)
        this.player = {
          x: 0,
          y: 0,
          vx: 0,
          vy: 0,
          radius: 15,
          color: '#22d3ee',
          health: 100,
          score: 0,
          speed: 4, // Base speed
          boosting: false,
          lastBoostParticle: 0
        };
        
        this.enemy = {
          x: 0,
          y: 0,
          vx: 0,
          vy: 0,
          radius: 15,
          color: '#ef4444',
          health: 100,
          score: 0,
          speed: 4, // Base speed
          boosting: false
        };
        
        // Level elements for solo mode
        this.obstacles = [];
        this.powerUps = [];
        this.lastPowerUpSpawn = 0;
        
        // Wolf enemies
        this.wolves = [];
        this.maxWolves = 3;
        this.lastWolfSpawn = 0;
        this.wolfSpawnInterval = 10000; // Spawn wolf every 10 seconds
        this.waveNumber = 1;
        
        this.score = { you: 0, them: 0 };
        this.startTime = Date.now();
        
        // Controls
        this.joystick = null;
        this.buttons = {};
        
        // Animation
        this.lastTime = 0;
        this.fps = 0;
        this.frameCount = 0;
        this.fpsTime = 0;
        
        // Store cleanup references
        this.animationId = null;
        this.connectionCheckInterval = null;
        this.connectionCheckTimeout = null;
        this.resizeHandler = () => this.resizeCanvas();
        this.orientationHandler = () => {
          setTimeout(() => this.resizeCanvas(), 100);
        };
        
        this.init();
      }

      setupMultiplayer() {
        // Set up callbacks
        this.multiplayer.onAttack = () => {
          // Visual feedback for attack
          this.showAttackEffect();
        };
        
        this.multiplayer.onHit = () => {
          // Visual feedback for being hit
          if ('vibrate' in navigator) {
            navigator.vibrate([50, 20, 50]);
          }
        };
        
        this.multiplayer.onScoreChange = () => {
          // Update score display
          this.updateScoreDisplay();
        };
        
        // The multiplayer instance will handle connection setup via BroadcastChannel
        // No need to manually pass connection here anymore
        console.log('Multiplayer game initialized, waiting for connection...');
        
        // Update UI to show connection status
        const connectionDot = document.getElementById('connectionDot');
        const connectionText = document.getElementById('connectionText');
        
        // Check connection status periodically
        this.connectionCheckInterval = setInterval(() => {
          if (this.multiplayer && this.multiplayer.dataChannel) {
            connectionDot.style.background = '#10b981';
            connectionText.textContent = 'Connected';
            clearInterval(this.connectionCheckInterval);
            this.connectionCheckInterval = null;
          } else {
            connectionDot.style.background = '#f59e0b';
            connectionText.textContent = 'Connecting...';
          }
        }, 500);
        
        // Timeout after 5 seconds
        this.connectionCheckTimeout = setTimeout(() => {
          if (!this.multiplayer.dataChannel) {
            connectionDot.style.background = '#ef4444';
            connectionText.textContent = 'Connection Failed';
            if (this.connectionCheckInterval) {
              clearInterval(this.connectionCheckInterval);
              this.connectionCheckInterval = null;
            }
          }
          this.connectionCheckTimeout = null;
        }, 5000);
      }

      showAttackEffect() {
        // Visual attack effect (will be rendered in next frame)
        this.attackEffect = {
          x: this.player.x,
          y: this.player.y,
          radius: 50,
          alpha: 1
        };
      }

      updateScoreDisplay() {
        if (this.multiplayer) {
          const state = this.multiplayer.getGameState();
          const myRole = this.multiplayer.role;
          
          if (myRole === 'host') {
            document.getElementById('scoreYou').textContent = state.players.host.score;
            document.getElementById('scoreThem').textContent = state.players.player.score;
          } else {
            document.getElementById('scoreYou').textContent = state.players.player.score;
            document.getElementById('scoreThem').textContent = state.players.host.score;
          }
        }
      }

      init() {
        // Setup canvas
        this.resizeCanvas();
        window.addEventListener('resize', this.resizeHandler);
        window.addEventListener('orientationchange', this.orientationHandler);
        
        // Initialize controls
        const deviceType = sessionStorage.getItem('deviceType') || 'mobile';
        if (deviceType === 'mobile' || 'ontouchstart' in window) {
          this.initMobileControls();
        } else {
          this.initDesktopControls();
        }
        
        // Generate level for solo mode
        if (!this.isMultiplayer) {
          this.generateLevel();
        }
        
        // Start game
        this.reset();
        this.start();
      }
      
      generateLevel() {
        // Clear existing level elements
        this.obstacles = [];
        this.powerUps = [];
        this.wolves = [];
        
        // Generate obstacles
        const numObstacles = 5 + Math.floor(Math.random() * 5);
        for (let i = 0; i < numObstacles; i++) {
          this.obstacles.push({
            x: Math.random() * this.canvas.width,
            y: Math.random() * this.canvas.height,
            radius: 20 + Math.random() * 30,
            color: '#4a5568'
          });
        }
        
        // Generate initial power-ups
        const numPowerUps = 3;
        for (let i = 0; i < numPowerUps; i++) {
          this.spawnPowerUp();
        }
        
        // Spawn initial wolves
        this.spawnWolf();
      }
      
      spawnPowerUp() {
        const types = ['speed', 'shield', 'points'];
        const colors = {
          speed: '#10b981',
          shield: '#3b82f6', 
          points: '#f59e0b'
        };
        
        const type = types[Math.floor(Math.random() * types.length)];
        
        this.powerUps.push({
          x: Math.random() * this.canvas.width,
          y: Math.random() * this.canvas.height,
          radius: 10,
          type: type,
          color: colors[type],
          collected: false
        });
      }
      
      spawnWolf() {
        if (this.wolves.length >= this.maxWolves) return;
        
        // Spawn wolf at edge of screen
        const edge = Math.floor(Math.random() * 4);
        let x, y;
        
        switch(edge) {
          case 0: // Top
            x = Math.random() * this.canvas.width;
            y = -30;
            break;
          case 1: // Right
            x = this.canvas.width + 30;
            y = Math.random() * this.canvas.height;
            break;
          case 2: // Bottom
            x = Math.random() * this.canvas.width;
            y = this.canvas.height + 30;
            break;
          case 3: // Left
            x = -30;
            y = Math.random() * this.canvas.height;
            break;
        }
        
        const wolf = {
          id: Date.now() + Math.random(),
          x: x,
          y: y,
          vx: 0,
          vy: 0,
          radius: 12,
          speed: 2 + (this.waveNumber * 0.3), // Wolves get faster each wave
          health: 2 + Math.floor(this.waveNumber / 2), // More health in later waves
          color: '#8b4513', // Brown color for wolves
          state: 'hunting', // hunting, stalking, attacking, fleeing
          targetX: this.canvas.width / 2,
          targetY: this.canvas.height / 2,
          lastAttack: 0,
          attackCooldown: 2000,
          alertRadius: 150, // Detection range
          attackRadius: 30, // Attack range
          fleeHealth: 1,
          animationPhase: 0,
          growlSound: false
        };
        
        this.wolves.push(wolf);
        
        if (window.debugMode) {
          console.log(`üê∫ Wolf spawned! Total wolves: ${this.wolves.length}, Wave: ${this.waveNumber}`);
        }
      }
      
      updateWolfAI(wolf, deltaTime) {
        const dx = this.player.x - wolf.x;
        const dy = this.player.y - wolf.y;
        const distToPlayer = Math.sqrt(dx * dx + dy * dy);
        
        // State machine for wolf behavior
        switch(wolf.state) {
          case 'hunting':
            // Move towards player
            if (distToPlayer < wolf.alertRadius) {
              wolf.state = 'stalking';
              wolf.growlSound = true;
            } else {
              // Wander around
              if (Math.random() < 0.02) {
                wolf.targetX = Math.random() * this.canvas.width;
                wolf.targetY = Math.random() * this.canvas.height;
              }
              const tdx = wolf.targetX - wolf.x;
              const tdy = wolf.targetY - wolf.y;
              const tdist = Math.sqrt(tdx * tdx + tdy * tdy);
              if (tdist > 5) {
                wolf.vx = (tdx / tdist) * wolf.speed * 0.5;
                wolf.vy = (tdy / tdist) * wolf.speed * 0.5;
              }
            }
            break;
            
          case 'stalking':
            // Circle around player
            if (distToPlayer < wolf.attackRadius) {
              wolf.state = 'attacking';
            } else if (distToPlayer > wolf.alertRadius * 1.5) {
              wolf.state = 'hunting';
            } else {
              // Move in a stalking pattern
              const angle = Math.atan2(dy, dx);
              const circleOffset = Math.sin(Date.now() * 0.002) * 0.5;
              wolf.vx = Math.cos(angle + circleOffset) * wolf.speed * 0.7;
              wolf.vy = Math.sin(angle + circleOffset) * wolf.speed * 0.7;
            }
            break;
            
          case 'attacking':
            // Lunge at player
            if (distToPlayer > wolf.attackRadius * 2) {
              wolf.state = 'stalking';
            } else {
              const angle = Math.atan2(dy, dx);
              wolf.vx = Math.cos(angle) * wolf.speed * 1.5;
              wolf.vy = Math.sin(angle) * wolf.speed * 1.5;
              
              // Try to attack
              const now = Date.now();
              if (now - wolf.lastAttack > wolf.attackCooldown && distToPlayer < wolf.attackRadius) {
                this.wolfAttack(wolf);
                wolf.lastAttack = now;
              }
            }
            break;
            
          case 'fleeing':
            // Run away from player
            if (distToPlayer > wolf.alertRadius * 2) {
              wolf.state = 'hunting';
            } else {
              const angle = Math.atan2(dy, dx);
              wolf.vx = -Math.cos(angle) * wolf.speed * 2;
              wolf.vy = -Math.sin(angle) * wolf.speed * 2;
            }
            break;
        }
        
        // Update position
        wolf.x += wolf.vx;
        wolf.y += wolf.vy;
        
        // Keep wolf in bounds (with margin for spawning)
        wolf.x = Math.max(-50, Math.min(this.canvas.width + 50, wolf.x));
        wolf.y = Math.max(-50, Math.min(this.canvas.height + 50, wolf.y));
        
        // Apply friction
        wolf.vx *= 0.95;
        wolf.vy *= 0.95;
        
        // Update animation
        wolf.animationPhase += deltaTime * 0.01;
        
        // Check if wolf should flee (low health)
        if (wolf.health <= wolf.fleeHealth && wolf.state !== 'fleeing') {
          wolf.state = 'fleeing';
        }
      }
      
      wolfAttack(wolf) {
        // Check if wolf hits player
        const dx = this.player.x - wolf.x;
        const dy = this.player.y - wolf.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < wolf.attackRadius + this.player.radius) {
          if (this.player.hasShield) {
            // Shield blocks the attack
            this.player.hasShield = false;
            
            // Visual feedback
            this.vfx.createExplosion(this.player.x, this.player.y, {
              color: '#3b82f6',
              particleCount: 30,
              force: 8
            });
            
            // Knock back wolf
            wolf.vx = -dx / dist * 10;
            wolf.vy = -dy / dist * 10;
            wolf.state = 'stalking';
          } else {
            // Player takes damage
            this.score.them++;
            document.getElementById('scoreThem').textContent = this.score.them;
            
            // Visual feedback
            this.vfx.createImpact(this.player.x, this.player.y, {
              color: '#8b4513',
              particleCount: 20,
              spread: 180
            });
            
            // Show damage number
            this.vfx.createDamageNumber(
              this.player.x,
              this.player.y - this.player.radius - 10,
              5,
              { isCritical: false }
            );
            
            // Knockback player
            this.player.vx += dx / dist * 5;
            this.player.vy += dy / dist * 5;
            
            // Haptic feedback
            if ('vibrate' in navigator) {
              navigator.vibrate([100, 50, 100]);
            }
          }
        }
      }
      
      damageWolf(wolf, damage) {
        wolf.health -= damage;
        
        // Visual feedback
        this.vfx.createImpact(wolf.x, wolf.y, {
          color: '#ff6b6b',
          particleCount: 15,
          spread: 180
        });
        
        // Show damage number
        this.vfx.createDamageNumber(
          wolf.x,
          wolf.y - wolf.radius - 10,
          damage,
          { isCritical: damage > 15 }
        );
        
        if (wolf.health <= 0) {
          // Wolf defeated
          this.score.you += 10;
          document.getElementById('scoreYou').textContent = this.score.you;
          
          // Death effect
          this.vfx.createExplosion(wolf.x, wolf.y, {
            color: '#8b4513',
            secondaryColor: '#ff6b6b',
            particleCount: 30,
            force: 8
          });
          
          // Chance to drop power-up
          if (Math.random() < 0.3) {
            this.powerUps.push({
              x: wolf.x,
              y: wolf.y,
              radius: 10,
              type: 'points',
              color: '#f59e0b',
              collected: false
            });
          }
          
          return true; // Wolf is dead
        }
        
        return false; // Wolf survived
      }
      
      destroy() {
        // Stop animation loop
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
          this.animationId = null;
        }
        
        // Clear intervals and timeouts
        if (this.connectionCheckInterval) {
          clearInterval(this.connectionCheckInterval);
          this.connectionCheckInterval = null;
        }
        if (this.connectionCheckTimeout) {
          clearTimeout(this.connectionCheckTimeout);
          this.connectionCheckTimeout = null;
        }
        
        // Remove event listeners
        window.removeEventListener('resize', this.resizeHandler);
        window.removeEventListener('orientationchange', this.orientationHandler);
        
        // Cleanup controls
        if (this.joystick) {
          this.joystick.destroy();
          this.joystick = null;
        }
        if (this.buttons.attack) {
          this.buttons.attack.destroy();
        }
        if (this.buttons.boost) {
          this.buttons.boost.destroy();
        }
        
        // Cleanup keyboard listeners if present
        if (this.keydownHandler) {
          window.removeEventListener('keydown', this.keydownHandler);
        }
        if (this.keyupHandler) {
          window.removeEventListener('keyup', this.keyupHandler);
        }
      }

      initMobileControls() {
        // Initialize joystick
        const joystickEl = document.getElementById('joystick');
        const joystickKnob = document.getElementById('joystickKnob');
        
        if (joystickEl && joystickKnob) {
          this.joystick = new JoystickController(joystickEl, joystickKnob);
        } else {
          console.error('Joystick elements not found');
        }
        
        // Initialize action buttons
        const attackBtn = document.getElementById('btnAttack');
        const boostBtn = document.getElementById('btnBoost');
        
        if (attackBtn) {
          this.buttons.attack = new ActionButton(attackBtn, 'attack');
        }
        if (boostBtn) {
          this.buttons.boost = new ActionButton(boostBtn, 'boost');
        }
        
        // Show mobile controls
        const mobileControls = document.getElementById('mobileControls');
        if (mobileControls) {
          mobileControls.style.display = 'block';
        }
        
        // Hide desktop controls
        const desktopControls = document.querySelector('.desktop-controls');
        if (desktopControls) {
          desktopControls.style.display = 'none';
        }
      }

      initDesktopControls() {
        // Hide mobile controls
        document.getElementById('mobileControls').style.display = 'none';
        
        // Keyboard controls
        this.keys = {};
        this.keydownHandler = (e) => {
          this.keys[e.key.toLowerCase()] = true;
          
          if (e.key === ' ') {
            e.preventDefault();
            this.handleAction('attack', true);
          }
          if (e.key === 'Shift') {
            e.preventDefault();
            this.handleAction('boost', true);
          }
        };
        
        this.keyupHandler = (e) => {
          this.keys[e.key.toLowerCase()] = false;
          
          if (e.key === ' ') {
            this.handleAction('attack', false);
          }
          if (e.key === 'Shift') {
            this.handleAction('boost', false);
          }
        };
        
        window.addEventListener('keydown', this.keydownHandler);
        window.addEventListener('keyup', this.keyupHandler);
      }

      resizeCanvas() {
        const container = this.canvas.parentElement;
        const width = container.clientWidth || window.innerWidth;
        const height = container.clientHeight || window.innerHeight;
        
        // Ensure canvas has valid dimensions
        if (width <= 0 || height <= 0) {
          console.error('Invalid canvas dimensions:', width, height);
          // Set default dimensions
          this.canvas.width = 800;
          this.canvas.height = 600;
        } else {
          this.canvas.width = width;
          this.canvas.height = height;
        }
        
        console.log('Canvas resized to:', this.canvas.width, 'x', this.canvas.height);
        
        // Reset player position
        if (this.player) {
          this.player.x = this.canvas.width / 2;
          this.player.y = this.canvas.height / 2;
        }
      }

      reset() {
        // Ensure player and enemy objects exist
        if (!this.player || !this.enemy) {
          console.warn('reset() called before player/enemy initialized');
          return;
        }
        
        this.player.x = this.canvas.width / 2;
        this.player.y = this.canvas.height / 2;
        this.player.vx = 0;
        this.player.vy = 0;
        
        this.enemy.x = this.canvas.width / 2;
        this.enemy.y = this.canvas.height / 4;
      }

      start() {
        this.running = true;
        this.animate();
      }

      stop() {
        this.running = false;
      }

      pause() {
        this.paused = true;
      }

      resume() {
        this.paused = false;
      }

      handleAction(action, pressed) {
        switch (action) {
          case 'attack':
            if (pressed && !this.isMultiplayer) {
              // Only handle attack locally in single player
              this.attack();
            }
            // In multiplayer, attack is handled in the update loop
            break;
          case 'boost':
            if (!this.isMultiplayer) {
              this.player.boosting = pressed;
            }
            // In multiplayer, boost is handled in the update loop
            break;
        }
      }

      attack() {
        // Create visual attack effect
        this.vfx.createImpact(this.player.x, this.player.y, {
          color: '#22d3ee',
          particleCount: 25,
          spread: 360
        });
        
        // Attack animation/effect
        const attackRadius = 50;
        this.ctx.strokeStyle = '#22d3ee';
        this.ctx.lineWidth = 3;
        this.ctx.beginPath();
        this.ctx.arc(this.player.x, this.player.y, attackRadius, 0, Math.PI * 2);
        this.ctx.stroke();
        
        // Check collision with wolves
        for (let i = this.wolves.length - 1; i >= 0; i--) {
          const wolf = this.wolves[i];
          const dx = wolf.x - this.player.x;
          const dy = wolf.y - this.player.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < attackRadius + wolf.radius) {
            // Calculate damage
            const damage = Math.floor(Math.random() * 10) + 10;
            const isDead = this.damageWolf(wolf, damage);
            
            if (isDead) {
              // Remove dead wolf
              this.wolves.splice(i, 1);
              
              if (window.debugMode) {
                console.log(`üéØ Wolf defeated! Remaining: ${this.wolves.length}`);
              }
            } else {
              // Knockback wolf
              wolf.vx = dx / distance * 10;
              wolf.vy = dy / distance * 10;
              wolf.state = 'fleeing';
            }
          }
        }
        
        // Check collision with enemy (in solo mode)
        if (!this.isMultiplayer && this.enemy) {
          const dx = this.enemy.x - this.player.x;
          const dy = this.enemy.y - this.player.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < attackRadius + this.enemy.radius) {
            // Hit confirmed - create explosion effect
            this.vfx.createExplosion(this.enemy.x, this.enemy.y, {
              color: '#ff6b6b',
              secondaryColor: '#ffd93d',
              particleCount: 40,
              force: 10,
              shakeIntensity: 8
            });
            
            // Show damage number
            const damage = Math.floor(Math.random() * 20) + 10;
            const isCritical = Math.random() < 0.2;
            this.vfx.createDamageNumber(
              this.enemy.x, 
              this.enemy.y - this.enemy.radius - 10, 
              damage,
              { isCritical }
            );
            
            this.score.you++;
            document.getElementById('scoreYou').textContent = this.score.you;
            
            // Haptic feedback
            if ('vibrate' in navigator) {
              navigator.vibrate([20, 10, 20]);
            }
          }
        }
      }

      update(deltaTime) {
        if (this.paused) return;
        
        // Get input
        let inputX = 0;
        let inputY = 0;
        
        if (this.joystick) {
          const vector = this.joystick.getVector();
          inputX = vector.x;
          inputY = vector.y;
        } else if (this.keys) {
          // Desktop keyboard input
          // Add acceleration for smoother control
          const targetX = ((this.keys['a'] || this.keys['arrowleft']) ? -1 : 0) + 
                         ((this.keys['d'] || this.keys['arrowright']) ? 1 : 0);
          const targetY = ((this.keys['w'] || this.keys['arrowup']) ? -1 : 0) + 
                         ((this.keys['s'] || this.keys['arrowdown']) ? 1 : 0);
          
          // Smooth acceleration (0.2 = 20% per frame)
          const smoothing = 0.2;
          if (!this.keyboardInput) {
            this.keyboardInput = { x: 0, y: 0 };
          }
          this.keyboardInput.x = this.keyboardInput.x * (1 - smoothing) + targetX * smoothing;
          this.keyboardInput.y = this.keyboardInput.y * (1 - smoothing) + targetY * smoothing;
          
          inputX = this.keyboardInput.x;
          inputY = this.keyboardInput.y;
          
          // Normalize diagonal movement
          const magnitude = Math.sqrt(inputX * inputX + inputY * inputY);
          if (magnitude > 1) {
            inputX /= magnitude;
            inputY /= magnitude;
          }
        }
        
        if (this.isMultiplayer && this.multiplayer) {
          // Update multiplayer input
          let boost = false;
          let attack = false;
          
          // Get button states from mobile controls
          if (this.buttons.boost) {
            boost = this.buttons.boost.isPressed();
          }
          if (this.buttons.attack) {
            attack = this.buttons.attack.isPressed();
          }
          
          // Get keyboard states for desktop
          if (this.keys) {
            boost = boost || this.keys['shift'];
            attack = attack || this.keys[' '];
          }
          
          this.multiplayer.updateLocalInput(inputX, inputY, boost, attack);
          this.multiplayer.updateLocalPosition(deltaTime);
          
          // Get synced game state
          const gameState = this.multiplayer.getGameState();
          const myRole = this.multiplayer.role;
          
          // Copy player data to avoid reference mutations (BUGFIX)
          if (myRole === 'host') {
            this.player = { ...gameState.players.host };
            this.enemy = { ...gameState.players.player };
          } else {
            this.player = { ...gameState.players.player };
            this.enemy = { ...gameState.players.host };
          }
          
          // Update latency display
          const latency = this.multiplayer.getLatency();
          const latencyEl = document.getElementById('connectionText');
          if (latencyEl) {
            latencyEl.textContent = `Connected (${latency}ms)`;
          }
        } else {
          // Single player movement
          const boostMultiplier = 2; // Boost multiplier
          const speed = this.player.boosting ? this.player.speed * boostMultiplier : this.player.speed;
          
          // Apply velocity with smoothing for consistency
          const smoothing = 0.2;
          this.player.vx = this.player.vx * (1 - smoothing) + (inputX * speed) * smoothing;
          this.player.vy = this.player.vy * (1 - smoothing) + (inputY * speed) * smoothing;
          
          this.player.x += this.player.vx;
          this.player.y += this.player.vy;
          
          // Keep player in bounds
          this.player.x = Math.max(this.player.radius, Math.min(this.canvas.width - this.player.radius, this.player.x));
          this.player.y = Math.max(this.player.radius, Math.min(this.canvas.height - this.player.radius, this.player.y));
        }
        
                  // Create boost trail effect
        if (this.player.boosting || (this.buttons.boost && this.buttons.boost.isPressed())) {
          const boostNow = performance.now();
          if (boostNow - this.player.lastBoostParticle > 30) {
            this.vfx.createBoostTrail(
              this.player.x, 
              this.player.y, 
              this.player.color,
              { x: this.player.vx, y: this.player.vy }
            );
            this.player.lastBoostParticle = boostNow;
          }
        }
        
        // Update visual effects
        this.vfx.update(deltaTime);
        
        // Solo mode level logic
        if (!this.isMultiplayer) {
          // Update wolves
          for (let i = this.wolves.length - 1; i >= 0; i--) {
            const wolf = this.wolves[i];
            this.updateWolfAI(wolf, deltaTime);
            
            // Check wolf-obstacle collisions
            for (const obstacle of this.obstacles) {
              const dx = wolf.x - obstacle.x;
              const dy = wolf.y - obstacle.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              
              if (dist < wolf.radius + obstacle.radius) {
                // Push wolf away from obstacle
                const pushAngle = Math.atan2(dy, dx);
                const pushForce = (wolf.radius + obstacle.radius - dist) * 0.5;
                wolf.x += Math.cos(pushAngle) * pushForce;
                wolf.y += Math.sin(pushAngle) * pushForce;
                wolf.vx *= 0.8;
                wolf.vy *= 0.8;
              }
            }
          }
          
          // Spawn new wolves periodically
          const wolfSpawnNow = Date.now();
          if (wolfSpawnNow - this.lastWolfSpawn > this.wolfSpawnInterval) {
            this.spawnWolf();
            this.lastWolfSpawn = wolfSpawnNow;
            
            // Increase difficulty over time
            if (this.wolves.length === 0) {
              // All wolves defeated, next wave!
              this.waveNumber++;
              this.maxWolves = Math.min(10, 3 + this.waveNumber);
              this.wolfSpawnInterval = Math.max(5000, 10000 - (this.waveNumber * 500));
              
              if (window.debugMode) {
                console.log(`üåä Wave ${this.waveNumber} started! Max wolves: ${this.maxWolves}`);
              }
              
              // Spawn multiple wolves for new wave
              const waveSize = Math.min(this.maxWolves, 2 + Math.floor(this.waveNumber / 2));
              for (let i = 0; i < waveSize; i++) {
                setTimeout(() => this.spawnWolf(), i * 500);
              }
            }
          }
          
          // Check collision with obstacles
          for (const obstacle of this.obstacles) {
            const dx = this.player.x - obstacle.x;
            const dy = this.player.y - obstacle.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < this.player.radius + obstacle.radius) {
              // Push player away from obstacle
              const pushAngle = Math.atan2(dy, dx);
              const pushForce = (this.player.radius + obstacle.radius - dist) * 0.5;
              this.player.x += Math.cos(pushAngle) * pushForce;
              this.player.y += Math.sin(pushAngle) * pushForce;
              
              // Slow down player
              this.player.vx *= 0.8;
              this.player.vy *= 0.8;
            }
            
            // Check enemy collision with obstacles
            const edx = this.enemy.x - obstacle.x;
            const edy = this.enemy.y - obstacle.y;
            const edist = Math.sqrt(edx * edx + edy * edy);
            
            if (edist < this.enemy.radius + obstacle.radius) {
              // Push enemy away from obstacle
              const pushAngle = Math.atan2(edy, edx);
              const pushForce = (this.enemy.radius + obstacle.radius - edist) * 0.5;
              this.enemy.x += Math.cos(pushAngle) * pushForce;
              this.enemy.y += Math.sin(pushAngle) * pushForce;
            }
          }
          
          // Check collision with power-ups
          for (let i = this.powerUps.length - 1; i >= 0; i--) {
            const powerUp = this.powerUps[i];
            if (powerUp.collected) continue;
            
            const dx = this.player.x - powerUp.x;
            const dy = this.player.y - powerUp.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < this.player.radius + powerUp.radius) {
              // Collect power-up
              powerUp.collected = true;
              
              // Apply power-up effect
              switch (powerUp.type) {
                case 'speed':
                  this.player.speed = 6; // Temporary speed boost
                  setTimeout(() => { this.player.speed = 4; }, 5000);
                  break;
                case 'shield':
                  // Visual shield effect (placeholder)
                  this.player.hasShield = true;
                  setTimeout(() => { this.player.hasShield = false; }, 5000);
                  break;
                case 'points':
                  this.score.you += 5;
                  document.getElementById('scoreYou').textContent = this.score.you;
                  break;
              }
              
              // Visual feedback
              this.vfx.createExplosion(powerUp.x, powerUp.y, {
                color: powerUp.color,
                particleCount: 20,
                force: 5
              });
              
              // Remove collected power-up
              this.powerUps.splice(i, 1);
            }
          }
          
          // Spawn new power-ups periodically
          const powerUpNow = Date.now();
          if (powerUpNow - this.lastPowerUpSpawn > 5000 && this.powerUps.length < 5) {
            this.spawnPowerUp();
            this.lastPowerUpSpawn = powerUpNow;
          }
        }
        
        // Simple enemy AI - only in solo mode
        if (!this.isMultiplayer) {
          const enemySpeed = 2;
          const dx = this.player.x - this.enemy.x;
          const dy = this.player.y - this.enemy.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist > 50) { // Keep some distance from player
            // Move towards player with some variation
            const angleToPlayer = Math.atan2(dy, dx);
            const wobble = Math.sin(Date.now() * 0.002) * 0.5; // Add some unpredictability
            
            this.enemy.x += Math.cos(angleToPlayer + wobble) * enemySpeed;
            this.enemy.y += Math.sin(angleToPlayer + wobble) * enemySpeed;
            
            // Keep enemy in bounds
            this.enemy.x = Math.max(this.enemy.radius, Math.min(this.canvas.width - this.enemy.radius, this.enemy.x));
            this.enemy.y = Math.max(this.enemy.radius, Math.min(this.canvas.height - this.enemy.radius, this.enemy.y));
          }
          
          // Enemy "attacks" when close
          if (dist < 100 && Math.random() < 0.01) { // 1% chance per frame when close
            // Visual feedback for enemy attack
            this.attackEffect = {
              x: this.enemy.x,
              y: this.enemy.y,
              radius: 50,
              alpha: 0.5
            };
            
            // Check if enemy hit player
            if (dist < 50) {
              if (this.player.hasShield) {
                // Shield blocks the attack
                this.player.hasShield = false; // Shield breaks
                
                // Visual feedback for shield break
                this.vfx.createExplosion(this.player.x, this.player.y, {
                  color: '#3b82f6',
                  particleCount: 30,
                  force: 8
                });
              } else {
                // Player takes damage
                this.score.them++;
                document.getElementById('scoreThem').textContent = this.score.them;
                
                // Visual feedback
                this.vfx.createImpact(this.player.x, this.player.y, {
                  color: '#ef4444',
                  particleCount: 15,
                  spread: 180
                });
                
                // Haptic feedback
                if ('vibrate' in navigator) {
                  navigator.vibrate([50]);
                }
              }
            }
          }
        }
        
        // Update timer
        const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        document.getElementById('gameTimer').textContent = 
          `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        // Update debug info
        if (window.debugMode) {
          document.getElementById('waveDebug').textContent = this.waveNumber;
          document.getElementById('wolvesDebug').textContent = `${this.wolves.length}/${this.maxWolves}`;
          document.getElementById('playerPosDebug').textContent = 
            `${Math.round(this.player.x)}, ${Math.round(this.player.y)}`;
          document.getElementById('scoreDebug').textContent = 
            `${this.score.you} - ${this.score.them}`;
        }
      }

      render() {
        // Check if context exists
        if (!this.ctx) {
          console.error('Canvas context is null in render');
          return;
        }
        
        // Clear canvas
        this.ctx.fillStyle = '#0a0e27';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw grid
        this.ctx.strokeStyle = 'rgba(99, 102, 241, 0.1)';
        this.ctx.lineWidth = 1;
        const gridSize = 50;
        
        for (let x = 0; x < this.canvas.width; x += gridSize) {
          this.ctx.beginPath();
          this.ctx.moveTo(x, 0);
          this.ctx.lineTo(x, this.canvas.height);
          this.ctx.stroke();
        }
        
        for (let y = 0; y < this.canvas.height; y += gridSize) {
          this.ctx.beginPath();
          this.ctx.moveTo(0, y);
          this.ctx.lineTo(this.canvas.width, y);
          this.ctx.stroke();
        }
        
        // Draw obstacles (solo mode only)
        if (!this.isMultiplayer && this.obstacles) {
          for (const obstacle of this.obstacles) {
            this.ctx.fillStyle = obstacle.color;
            this.ctx.beginPath();
            this.ctx.arc(obstacle.x, obstacle.y, obstacle.radius, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Add border for better visibility
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            this.ctx.lineWidth = 2;
            this.ctx.stroke();
          }
        }
        
        // Draw power-ups (solo mode only)
        if (!this.isMultiplayer && this.powerUps) {
          for (const powerUp of this.powerUps) {
            if (powerUp.collected) continue;
            
            // Pulsing effect
            const pulse = Math.sin(Date.now() * 0.005) * 0.2 + 1;
            const radius = powerUp.radius * pulse;
            
            // Glow effect
            this.ctx.shadowBlur = 15;
            this.ctx.shadowColor = powerUp.color;
            
            this.ctx.fillStyle = powerUp.color;
            this.ctx.beginPath();
            this.ctx.arc(powerUp.x, powerUp.y, radius, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Icon or symbol
            this.ctx.shadowBlur = 0;
            this.ctx.fillStyle = 'white';
            this.ctx.font = '12px sans-serif';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            
            const symbols = {
              speed: '‚ö°',
              shield: 'üõ°',
              points: '‚òÖ'
            };
            this.ctx.fillText(symbols[powerUp.type] || '?', powerUp.x, powerUp.y);
          }
        }
        
        // Draw wolves
        for (const wolf of this.wolves) {
          // Draw wolf body
          this.ctx.save();
          this.ctx.translate(wolf.x, wolf.y);
          
          // Wolf shape (simple representation)
          this.ctx.fillStyle = wolf.color;
          
          // Body
          this.ctx.beginPath();
          this.ctx.ellipse(0, 0, wolf.radius * 1.2, wolf.radius, 0, 0, Math.PI * 2);
          this.ctx.fill();
          
          // Head
          this.ctx.beginPath();
          const headAngle = Math.atan2(wolf.vy, wolf.vx);
          const headX = Math.cos(headAngle) * wolf.radius * 0.8;
          const headY = Math.sin(headAngle) * wolf.radius * 0.8;
          this.ctx.arc(headX, headY, wolf.radius * 0.7, 0, Math.PI * 2);
          this.ctx.fill();
          
          // Eyes (red when attacking, yellow when stalking, white when hunting)
          let eyeColor = 'white';
          if (wolf.state === 'attacking') eyeColor = '#ff0000';
          else if (wolf.state === 'stalking') eyeColor = '#ffff00';
          else if (wolf.state === 'fleeing') eyeColor = '#00ff00';
          
          this.ctx.fillStyle = eyeColor;
          const eyeOffset = wolf.radius * 0.3;
          const eyeAngle1 = headAngle - 0.3;
          const eyeAngle2 = headAngle + 0.3;
          
          // Left eye
          this.ctx.beginPath();
          this.ctx.arc(
            headX + Math.cos(eyeAngle1) * eyeOffset,
            headY + Math.sin(eyeAngle1) * eyeOffset,
            2, 0, Math.PI * 2
          );
          this.ctx.fill();
          
          // Right eye
          this.ctx.beginPath();
          this.ctx.arc(
            headX + Math.cos(eyeAngle2) * eyeOffset,
            headY + Math.sin(eyeAngle2) * eyeOffset,
            2, 0, Math.PI * 2
          );
          this.ctx.fill();
          
          // Health bar
          const maxHealth = 2 + Math.floor(this.waveNumber / 2);
          if (wolf.health < maxHealth) {
            this.ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
            this.ctx.fillRect(-wolf.radius, -wolf.radius - 10, wolf.radius * 2, 3);
            this.ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
            const healthPercent = Math.max(0, wolf.health / maxHealth);
            this.ctx.fillRect(-wolf.radius, -wolf.radius - 10, wolf.radius * 2 * healthPercent, 3);
          }
          
          // State indicator (debug)
          if (window.debugMode) {
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            this.ctx.font = '10px monospace';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(wolf.state, 0, -wolf.radius - 15);
          }
          
          this.ctx.restore();
          
          // Draw alert radius when stalking (debug)
          if (window.debugMode && wolf.state === 'stalking') {
            this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.2)';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.arc(wolf.x, wolf.y, wolf.alertRadius, 0, Math.PI * 2);
            this.ctx.stroke();
          }
        }
        
        // Draw attack effect if active
        if (this.attackEffect && this.attackEffect.alpha > 0) {
          this.ctx.strokeStyle = `rgba(34, 211, 238, ${this.attackEffect.alpha})`;
          this.ctx.lineWidth = 3;
          this.ctx.beginPath();
          this.ctx.arc(this.attackEffect.x, this.attackEffect.y, this.attackEffect.radius, 0, Math.PI * 2);
          this.ctx.stroke();
          
          // Fade out
          this.attackEffect.alpha -= 0.05;
          this.attackEffect.radius += 2;
        }
        
        // Draw enemy/other player
        if (this.enemy) {
          this.ctx.fillStyle = this.enemy.color || '#ef4444';
          if (this.enemy.boosting) {
            this.ctx.shadowBlur = 20;
            this.ctx.shadowColor = this.enemy.color || '#ef4444';
          }
          this.ctx.beginPath();
          this.ctx.arc(this.enemy.x, this.enemy.y, this.enemy.radius, 0, Math.PI * 2);
          this.ctx.fill();
          this.ctx.shadowBlur = 0;
          
          // Draw name tag for multiplayer
          if (this.isMultiplayer) {
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            this.ctx.font = '12px sans-serif';
            this.ctx.textAlign = 'center';
            const enemyName = this.multiplayer.role === 'host' ? 'Player' : 'Host';
            this.ctx.fillText(enemyName, this.enemy.x, this.enemy.y - this.enemy.radius - 10);
          }
        }
        
        // Draw player
        this.ctx.fillStyle = this.player.color || '#6366f1';
        if (this.player.boosting) {
          // Boost effect
          this.ctx.shadowBlur = 20;
          this.ctx.shadowColor = this.player.color || '#6366f1';
        }
        this.ctx.beginPath();
        this.ctx.arc(this.player.x, this.player.y, this.player.radius, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;
        
        // Draw shield if active
        if (this.player.hasShield) {
          this.ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
          this.ctx.lineWidth = 3;
          this.ctx.beginPath();
          this.ctx.arc(this.player.x, this.player.y, this.player.radius + 10, 0, Math.PI * 2);
          this.ctx.stroke();
          
          // Inner shield glow
          this.ctx.strokeStyle = 'rgba(59, 130, 246, 0.3)';
          this.ctx.lineWidth = 5;
          this.ctx.beginPath();
          this.ctx.arc(this.player.x, this.player.y, this.player.radius + 5, 0, Math.PI * 2);
          this.ctx.stroke();
        }
        
        // Draw name tag for multiplayer
        if (this.isMultiplayer) {
          this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
          this.ctx.font = '12px sans-serif';
          this.ctx.textAlign = 'center';
          this.ctx.fillText('You', this.player.x, this.player.y - this.player.radius - 10);
        }
        
        // Draw player direction indicator
        if (Math.abs(this.player.vx) > 0.1 || Math.abs(this.player.vy) > 0.1) {
          const angle = Math.atan2(this.player.vy, this.player.vx);
          const arrowLength = 30;
          const arrowX = this.player.x + Math.cos(angle) * arrowLength;
          const arrowY = this.player.y + Math.sin(angle) * arrowLength;
          
          this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
          this.ctx.lineWidth = 2;
          this.ctx.beginPath();
          this.ctx.moveTo(this.player.x, this.player.y);
          this.ctx.lineTo(arrowX, arrowY);
          this.ctx.stroke();
        }
      }

      animate(currentTime = 0) {
        if (!this.running) return;
        
        // Calculate delta time with spike protection (BUGFIX)
        let deltaTime = currentTime - this.lastTime;
        
        // Cap deltaTime to prevent huge jumps (max 100ms)
        if (this.lastTime === 0 || deltaTime > 100) {
          deltaTime = 16.67; // Assume 60fps for first frame or lag spikes
        }
        
        this.lastTime = currentTime;
        
        // Update FPS
        this.frameCount++;
        if (currentTime - this.fpsTime > 1000) {
          this.fps = this.frameCount;
          this.frameCount = 0;
          this.fpsTime = currentTime;
          
          if (window.debugMode) {
            document.getElementById('fps').textContent = this.fps;
          }
        }
        
        // Update and render
        this.update(deltaTime);
        this.render();
        
        // Continue animation loop
        this.animationId = requestAnimationFrame(this.animate.bind(this));
      }
    }

    // Initialize game
    let gameInstance = null;
    window.debugMode = true; // Enable debug mode to show FPS

    document.addEventListener('DOMContentLoaded', () => {
      const canvas = document.getElementById('gameCanvas');
      gameInstance = new MobileGame(canvas);
      window.gameInstance = gameInstance;
      
      // Update device debug info
      const deviceType = sessionStorage.getItem('deviceType') || 'auto-detected';
      const isMobile = 'ontouchstart' in window;
      document.getElementById('deviceDebug').textContent = `${deviceType} (${isMobile ? 'touch' : 'no-touch'})`;
      
      // Debug keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        // Toggle debug with backtick key
        if (e.key === '`') {
          e.preventDefault();
          window.toggleDebug();
        }
        
        // Debug commands (only when debug mode is active)
        if (window.debugMode) {
          switch(e.key) {
            case '1': // Spawn wolf
              e.preventDefault();
              if (gameInstance && !gameInstance.isMultiplayer) {
                gameInstance.spawnWolf();
                console.log('üê∫ Debug: Spawned wolf');
              }
              break;
            case '2': // Clear wolves
              e.preventDefault();
              if (gameInstance && !gameInstance.isMultiplayer) {
                gameInstance.wolves = [];
                console.log('üßπ Debug: Cleared all wolves');
              }
              break;
            case '3': // Next wave
              e.preventDefault();
              if (gameInstance && !gameInstance.isMultiplayer) {
                gameInstance.waveNumber++;
                gameInstance.maxWolves = Math.min(10, 3 + gameInstance.waveNumber);
                console.log(`üåä Debug: Advanced to wave ${gameInstance.waveNumber}`);
              }
              break;
            case '4': // Give shield
              e.preventDefault();
              if (gameInstance) {
                gameInstance.player.hasShield = true;
                console.log('üõ° Debug: Shield activated');
              }
              break;
            case '5': // Spawn power-up
              e.preventDefault();
              if (gameInstance && !gameInstance.isMultiplayer) {
                gameInstance.spawnPowerUp();
                console.log('‚≠ê Debug: Spawned power-up');
              }
              break;
            case '0': // Reset game
              e.preventDefault();
              if (gameInstance) {
                gameInstance.reset();
                gameInstance.generateLevel();
                gameInstance.score = { you: 0, them: 0 };
                gameInstance.waveNumber = 1;
                document.getElementById('scoreYou').textContent = '0';
                document.getElementById('scoreThem').textContent = '0';
                console.log('üîÑ Debug: Game reset');
              }
              break;
          }
        }
      });
    });

    // Global functions
    window.togglePause = function() {
      const pauseMenu = document.getElementById('pauseMenu');
      if (pauseMenu.classList.contains('active')) {
        resumeGame();
      } else {
        pauseMenu.classList.add('active');
        if (gameInstance) gameInstance.pause();
      }
    };

    window.resumeGame = function() {
      document.getElementById('pauseMenu').classList.remove('active');
      if (gameInstance) gameInstance.resume();
    };

    window.toggleDebug = function() {
      window.debugMode = !window.debugMode;
      document.getElementById('debugInfo').classList.toggle('active');
      document.getElementById('debugLegend').classList.toggle('active');
      console.log(`üîß Debug mode: ${window.debugMode ? 'ON' : 'OFF'}`);
    };

    window.exitGame = function() {
      if (confirm('Exit to main menu?')) {
        window.location.href = 'menu.html';
      }
    };

    // Handle connection status
    const updateConnectionStatus = () => {
      const isConnected = sessionStorage.getItem('p2pConnected') === 'true';
      const dot = document.getElementById('connectionDot');
      const text = document.getElementById('connectionText');
      
      if (isConnected) {
        dot.classList.remove('disconnected');
        text.textContent = 'Connected';
      } else {
        dot.classList.add('disconnected');
        text.textContent = sessionStorage.getItem('gameMode') === 'solo' ? 'Solo' : 'Offline';
      }
    };

    updateConnectionStatus();
    setInterval(updateConnectionStatus, 5000);

    // Prevent default touch behaviors
    document.addEventListener('touchmove', (e) => {
      if (e.target.closest('.mobile-controls') || e.target === document.getElementById('gameCanvas')) {
        e.preventDefault();
      }
    }, { passive: false });

    // Handle visibility change
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && gameInstance && !gameInstance.paused) {
        togglePause();
      }
    });

    // Register service worker for offline support
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js').catch(err => {
          console.error('Service worker registration failed:', err);
        });
      });
    }
  </script>
  
  <!-- Debug Panel -->
  <script type="module">
    // Load debug panel if in development mode or debug parameter is present
    const urlParams = new URLSearchParams(window.location.search);
    const debugMode = urlParams.has('debug') || window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    
    if (debugMode) {
      import('./src/debug/debug-panel.js').then(module => {
        console.log('üîß Debug Panel loaded - Press F12 or ` to toggle');
        
        // Make debug panel accessible globally
        window.debugPanel = module.default || window.debugPanel;
        
        // Auto-show if debug=true in URL
        if (urlParams.get('debug') === 'true') {
          setTimeout(() => window.debugPanel.show(), 500);
        }
      }).catch(err => {
        console.warn('Debug panel not available:', err);
      });
    }
  </script>
</body>
</html>