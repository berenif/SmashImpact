<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Enemy AI - Hunting Behaviors Demo</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .subtitle {
            text-align: center;
            font-size: 1.2em;
            margin-bottom: 20px;
            opacity: 0.9;
        }
        
        .game-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        canvas {
            display: block;
            margin: 0 auto;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            background: #1a1a2e;
            cursor: crosshair;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .control-group {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .control-group h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
            color: #ffd700;
        }
        
        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 5px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }
        
        .info-item {
            text-align: center;
        }
        
        .info-label {
            font-size: 0.9em;
            opacity: 0.7;
            margin-bottom: 5px;
        }
        
        .info-value {
            font-size: 1.3em;
            font-weight: bold;
            color: #ffd700;
        }
        
        .legend {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }
        
        .legend h3 {
            margin-top: 0;
            color: #ffd700;
        }
        
        .legend-item {
            display: inline-block;
            margin: 5px 15px 5px 0;
        }
        
        .legend-color {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 5px;
            vertical-align: middle;
            border: 1px solid rgba(255,255,255,0.3);
        }
        
        .debug-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }
        
        #debugCheckbox {
            margin-right: 10px;
        }
        
        .scenario-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ Advanced Enemy AI System</h1>
        <div class="subtitle">Intelligent Hunting, Flanking & Tactical Behaviors</div>
        
        <div class="debug-toggle">
            <label>
                <input type="checkbox" id="debugCheckbox"> Show AI Debug Info
            </label>
        </div>
        
        <div class="game-container">
            <canvas id="gameCanvas" width="1000" height="600"></canvas>
            
            <div class="info-panel">
                <div class="info-item">
                    <div class="info-label">Player Health</div>
                    <div class="info-value" id="playerHealth">100</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Enemies Active</div>
                    <div class="info-value" id="enemyCount">0</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Alert Level</div>
                    <div class="info-value" id="alertLevel">Calm</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Time Survived</div>
                    <div class="info-value" id="survivalTime">0s</div>
                </div>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <h3>üéÆ Player Controls</h3>
                    <p style="font-size: 0.9em; margin: 5px 0;">
                        <strong>WASD:</strong> Move<br>
                        <strong>Mouse:</strong> Aim<br>
                        <strong>Click:</strong> Shoot<br>
                        <strong>Shift:</strong> Sprint<br>
                        <strong>Space:</strong> Take Cover
                    </p>
                </div>
                
                <div class="control-group">
                    <h3>üéØ Spawn Enemies</h3>
                    <button onclick="spawnEnemy('soldier')">Spawn Soldier</button>
                    <button onclick="spawnEnemy('sniper')">Spawn Sniper</button>
                    <button onclick="spawnEnemy('assault')">Spawn Assault</button>
                    <button onclick="spawnSquad()">Spawn Squad (3)</button>
                </div>
                
                <div class="control-group">
                    <h3>üé¨ Scenarios</h3>
                    <div class="scenario-buttons">
                        <button onclick="loadScenario('ambush')">Ambush</button>
                        <button onclick="loadScenario('hunt')">Hunt Mode</button>
                        <button onclick="loadScenario('flank')">Flanking</button>
                        <button onclick="loadScenario('siege')">Siege</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>‚öôÔ∏è Game Control</h3>
                    <button onclick="clearEnemies()">Clear Enemies</button>
                    <button onclick="resetGame()">Reset Game</button>
                    <button onclick="togglePause()">Pause/Resume</button>
                    <button onclick="addObstacles()">Add Cover</button>
                </div>
            </div>
            
            <div class="legend">
                <h3>Legend</h3>
                <div class="legend-item">
                    <span class="legend-color" style="background: #00ff00;"></span>
                    Player
                </div>
                <div class="legend-item">
                    <span class="legend-color" style="background: #ff8800;"></span>
                    Soldier (Balanced)
                </div>
                <div class="legend-item">
                    <span class="legend-color" style="background: #800080;"></span>
                    Sniper (Long Range)
                </div>
                <div class="legend-item">
                    <span class="legend-color" style="background: #ff4444;"></span>
                    Assault (Aggressive)
                </div>
                <div class="legend-item">
                    <span class="legend-color" style="background: #666;"></span>
                    Cover/Obstacles
                </div>
            </div>
        </div>
    </div>
    
    <script src="src/ai/advanced-enemy-ai.js"></script>
    <script>
        // Game state
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let game = {
            player: null,
            enemies: [],
            obstacles: [],
            projectiles: [],
            particles: [],
            paused: false,
            startTime: Date.now(),
            lastTime: 0, // Initialize to 0, will be set in gameLoop
            mouseX: 0,
            mouseY: 0,
            keys: {},
            camera: {x: 0, y: 0}
        };
        
        // Player class
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.id = 'player';
                this.health = 100;
                this.maxHealth = 100;
                this.speed = 4;
                this.team = 'player';
                this.velocity = {x: 0, y: 0};
                this.rotation = 0;
                this.radius = 12;
                this.shootCooldown = 0;
                this.isInCover = false;
            }
            
            update(deltaTime) {
                // Movement
                let dx = 0, dy = 0;
                
                if (game.keys['w'] || game.keys['W']) dy -= 1;
                if (game.keys['s'] || game.keys['S']) dy += 1;
                if (game.keys['a'] || game.keys['A']) dx -= 1;
                if (game.keys['d'] || game.keys['D']) dx += 1;
                
                // Normalize diagonal movement
                if (dx !== 0 && dy !== 0) {
                    dx *= 0.707;
                    dy *= 0.707;
                }
                
                // Sprint
                let speed = this.speed;
                if (game.keys['Shift']) {
                    speed *= 1.5;
                }
                
                // Apply movement - scale speed properly for pixels per second
                const pixelsPerSecond = speed * 60; // Convert to pixels per second
                this.velocity.x = dx * pixelsPerSecond;
                this.velocity.y = dy * pixelsPerSecond;
                
                // Update position with collision - deltaTime is in milliseconds
                const dt = Math.min(deltaTime / 1000, 0.1); // Cap delta time to prevent teleporting
                const newX = this.x + this.velocity.x * dt;
                const newY = this.y + this.velocity.y * dt;
                
                if (!this.checkCollision(newX, newY)) {
                    this.x = newX;
                    this.y = newY;
                }
                
                // Update rotation to face mouse
                const dx2 = game.mouseX - canvas.width/2;
                const dy2 = game.mouseY - canvas.height/2;
                this.rotation = Math.atan2(dy2, dx2);
                
                // Update cover status
                this.isInCover = game.keys[' '] && this.nearCover();
                
                // Update shoot cooldown
                if (this.shootCooldown > 0) {
                    this.shootCooldown -= deltaTime;
                }
            }
            
            checkCollision(x, y) {
                // Check canvas boundaries
                if (x - this.radius < 0 || x + this.radius > canvas.width ||
                    y - this.radius < 0 || y + this.radius > canvas.height) {
                    return true;
                }
                
                // Check obstacle collisions
                for (const obstacle of game.obstacles) {
                    if (x + this.radius > obstacle.x - obstacle.width/2 &&
                        x - this.radius < obstacle.x + obstacle.width/2 &&
                        y + this.radius > obstacle.y - obstacle.height/2 &&
                        y - this.radius < obstacle.y + obstacle.height/2) {
                        return true;
                    }
                }
                return false;
            }
            
            nearCover() {
                for (const obstacle of game.obstacles) {
                    const dist = Math.hypot(obstacle.x - this.x, obstacle.y - this.y);
                    if (dist < obstacle.width/2 + obstacle.height/2 + 20) {
                        return true;
                    }
                }
                return false;
            }
            
            shoot() {
                if (this.shootCooldown <= 0) {
                    const angle = this.rotation;
                    game.projectiles.push(new Projectile(
                        this.x + Math.cos(angle) * 20,
                        this.y + Math.sin(angle) * 20,
                        Math.cos(angle) * 10,
                        Math.sin(angle) * 10,
                        this.team
                    ));
                    this.shootCooldown = 200;
                    
                    // Alert enemies to gunshot
                    for (const enemy of game.enemies) {
                        if (enemy.perception) {
                            enemy.perception.registerSound(this.x, this.y, 'gunshot');
                        }
                    }
                }
            }
            
            takeDamage(damage) {
                this.health = Math.max(0, this.health - damage);
                
                // Create damage particles
                for (let i = 0; i < 5; i++) {
                    game.particles.push(new Particle(
                        this.x, this.y,
                        (Math.random() - 0.5) * 5,
                        (Math.random() - 0.5) * 5,
                        '#ff0000'
                    ));
                }
            }
            
            render(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // Body
                ctx.fillStyle = this.isInCover ? '#008800' : '#00ff00';
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Gun
                ctx.fillStyle = '#333';
                ctx.fillRect(this.radius - 2, -3, 15, 6);
                
                ctx.restore();
                
                // Health bar
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(this.x - 20, this.y - 30, 40, 4);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(this.x - 20, this.y - 30, 40 * (this.health / this.maxHealth), 4);
            }
        }
        
        // Projectile class
        class Projectile {
            constructor(x, y, vx, vy, team) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.team = team;
                this.radius = 3;
                this.damage = 10;
                this.alive = true;
            }
            
            update(deltaTime) {
                const dt = deltaTime / 1000;
                this.x += this.vx * dt * 60;
                this.y += this.vy * dt * 60;
                
                // Check boundaries
                if (this.x < 0 || this.x > canvas.width ||
                    this.y < 0 || this.y > canvas.height) {
                    this.alive = false;
                }
                
                // Check obstacle collision
                for (const obstacle of game.obstacles) {
                    if (this.x > obstacle.x - obstacle.width/2 &&
                        this.x < obstacle.x + obstacle.width/2 &&
                        this.y > obstacle.y - obstacle.height/2 &&
                        this.y < obstacle.y + obstacle.height/2) {
                        this.alive = false;
                        break;
                    }
                }
                
                // Check entity collision
                const targets = this.team === 'player' ? game.enemies : [game.player];
                for (const target of targets) {
                    if (!target) continue;
                    
                    const dist = Math.hypot(target.x - this.x, target.y - this.y);
                    if (dist < (target.radius || 15)) {
                        target.takeDamage(this.damage);
                        this.alive = false;
                        break;
                    }
                }
            }
            
            render(ctx) {
                ctx.fillStyle = this.team === 'player' ? '#ffff00' : '#ff00ff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Particle class
        class Particle {
            constructor(x, y, vx, vy, color) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = 1;
                this.alive = true;
            }
            
            update(deltaTime) {
                const dt = deltaTime / 1000;
                this.x += this.vx * dt * 60;
                this.y += this.vy * dt * 60;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life -= dt * 2;
                
                if (this.life <= 0) {
                    this.alive = false;
                }
            }
            
            render(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - 2, this.y - 2, 4, 4);
                ctx.globalAlpha = 1;
            }
        }
        
        // Obstacle class
        class Obstacle {
            constructor(x, y, width, height, type = 'wall') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type;
            }
            
            render(ctx) {
                ctx.fillStyle = this.type === 'elevated' ? '#888' : '#666';
                ctx.fillRect(
                    this.x - this.width/2,
                    this.y - this.height/2,
                    this.width,
                    this.height
                );
                
                // Add some depth
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 2;
                ctx.strokeRect(
                    this.x - this.width/2,
                    this.y - this.height/2,
                    this.width,
                    this.height
                );
            }
        }
        
        // Initialize game
        function initGame() {
            // Create player
            game.player = new Player(canvas.width / 2, canvas.height / 2);
            
            // Create initial obstacles
            createDefaultObstacles();
            
            // Start game loop
            requestAnimationFrame(gameLoop);
        }
        
        function createDefaultObstacles() {
            game.obstacles = [
                // Walls
                new Obstacle(200, 200, 80, 20),
                new Obstacle(800, 200, 80, 20),
                new Obstacle(200, 400, 80, 20),
                new Obstacle(800, 400, 80, 20),
                
                // Cover points
                new Obstacle(400, 150, 40, 40),
                new Obstacle(600, 150, 40, 40),
                new Obstacle(400, 450, 40, 40),
                new Obstacle(600, 450, 40, 40),
                
                // Central structure
                new Obstacle(500, 300, 60, 60, 'elevated'),
                
                // Side walls
                new Obstacle(100, 300, 20, 200),
                new Obstacle(900, 300, 20, 200),
            ];
        }
        
        // Game loop
        function gameLoop(currentTime) {
            if (!game.paused) {
                // Ensure we have a valid lastTime
                if (!game.lastTime) {
                    game.lastTime = currentTime;
                }
                
                const deltaTime = Math.min(currentTime - game.lastTime, 100); // Cap at 100ms
                game.lastTime = currentTime;
                
                // Only update if we have a reasonable deltaTime
                if (deltaTime > 0 && deltaTime < 100) {
                    update(deltaTime);
                    render();
                    updateUI();
                }
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        function update(deltaTime) {
            // Update player
            if (game.player) {
                game.player.update(deltaTime);
                
                // Camera follow (simple)
                game.camera.x = game.player.x - canvas.width / 2;
                game.camera.y = game.player.y - canvas.height / 2;
            }
            
            // Update enemies
            const entities = [game.player, ...game.enemies].filter(e => e);
            
            for (let i = game.enemies.length - 1; i >= 0; i--) {
                const enemy = game.enemies[i];
                
                if (enemy.health <= 0) {
                    game.enemies.splice(i, 1);
                    continue;
                }
                
                enemy.update(deltaTime, entities, game.obstacles, {obstacles: game.obstacles});
            }
            
            // Update projectiles
            for (let i = game.projectiles.length - 1; i >= 0; i--) {
                const projectile = game.projectiles[i];
                projectile.update(deltaTime);
                
                if (!projectile.alive) {
                    game.projectiles.splice(i, 1);
                }
            }
            
            // Update particles
            for (let i = game.particles.length - 1; i >= 0; i--) {
                const particle = game.particles[i];
                particle.update(deltaTime);
                
                if (!particle.alive) {
                    game.particles.splice(i, 1);
                }
            }
        }
        
        function render() {
            // Clear canvas
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw obstacles
            for (const obstacle of game.obstacles) {
                obstacle.render(ctx);
            }
            
            // Draw enemies
            for (const enemy of game.enemies) {
                enemy.render(ctx);
                
                // Draw perception debug
                if (window.DEBUG_AI && enemy.perception) {
                    // Draw sight range
                    ctx.strokeStyle = 'rgba(255,0,0,0.2)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.perception.config.sightRange * 50, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Draw sight cone
                    const angle = enemy.rotation || 0;
                    const fov = (enemy.perception.config.sightAngle * Math.PI / 180) / 2;
                    
                    ctx.fillStyle = 'rgba(255,255,0,0.1)';
                    ctx.beginPath();
                    ctx.moveTo(enemy.x, enemy.y);
                    ctx.arc(enemy.x, enemy.y, enemy.perception.config.sightRange * 50, 
                           angle - fov, angle + fov);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Draw last known positions
                    for (const [id, pos] of enemy.perception.memory.lastKnownPositions) {
                        ctx.fillStyle = 'rgba(255,0,255,0.5)';
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // Draw projectiles
            for (const projectile of game.projectiles) {
                projectile.render(ctx);
            }
            
            // Draw particles
            for (const particle of game.particles) {
                particle.render(ctx);
            }
            
            // Draw player
            if (game.player) {
                game.player.render(ctx);
            }
        }
        
        function updateUI() {
            document.getElementById('playerHealth').textContent = 
                game.player ? Math.round(game.player.health) : 0;
            document.getElementById('enemyCount').textContent = game.enemies.length;
            
            // Calculate alert level
            let alertLevel = 'Calm';
            let alertedCount = 0;
            for (const enemy of game.enemies) {
                if (enemy.perception?.getPrimaryThreat()) {
                    alertedCount++;
                }
            }
            
            if (alertedCount > 0) {
                if (alertedCount === game.enemies.length) {
                    alertLevel = 'Combat!';
                } else if (alertedCount > game.enemies.length / 2) {
                    alertLevel = 'High Alert';
                } else {
                    alertLevel = 'Alerted';
                }
            }
            
            document.getElementById('alertLevel').textContent = alertLevel;
            
            const survivalTime = Math.floor((Date.now() - game.startTime) / 1000);
            document.getElementById('survivalTime').textContent = survivalTime + 's';
        }
        
        // Spawn functions
        function spawnEnemy(type) {
            const angle = Math.random() * Math.PI * 2;
            const distance = 200 + Math.random() * 100;
            const x = game.player.x + Math.cos(angle) * distance;
            const y = game.player.y + Math.sin(angle) * distance;
            
            // Ensure spawn position is valid
            const spawnX = Math.max(50, Math.min(canvas.width - 50, x));
            const spawnY = Math.max(50, Math.min(canvas.height - 50, y));
            
            const enemy = window.AdvancedEnemyAI.createEnemy(spawnX, spawnY, type);
            game.enemies.push(enemy);
        }
        
        function spawnSquad() {
            const types = ['soldier', 'soldier', 'assault'];
            const centerAngle = Math.random() * Math.PI * 2;
            const distance = 250;
            
            for (let i = 0; i < types.length; i++) {
                const angle = centerAngle + (i - 1) * 0.3;
                const x = game.player.x + Math.cos(angle) * distance;
                const y = game.player.y + Math.sin(angle) * distance;
                
                const spawnX = Math.max(50, Math.min(canvas.width - 50, x));
                const spawnY = Math.max(50, Math.min(canvas.height - 50, y));
                
                const enemy = window.AdvancedEnemyAI.createEnemy(spawnX, spawnY, types[i]);
                game.enemies.push(enemy);
            }
        }
        
        // Scenario functions
        function loadScenario(scenario) {
            clearEnemies();
            
            switch(scenario) {
                case 'ambush':
                    // Enemies hidden around corners
                    game.enemies.push(
                        window.AdvancedEnemyAI.createEnemy(150, 150, 'sniper'),
                        window.AdvancedEnemyAI.createEnemy(850, 150, 'sniper'),
                        window.AdvancedEnemyAI.createEnemy(500, 100, 'soldier')
                    );
                    break;
                    
                case 'hunt':
                    // Player is being hunted
                    game.enemies.push(
                        window.AdvancedEnemyAI.createEnemy(100, 100, 'assault'),
                        window.AdvancedEnemyAI.createEnemy(900, 100, 'assault'),
                        window.AdvancedEnemyAI.createEnemy(500, 50, 'soldier'),
                        window.AdvancedEnemyAI.createEnemy(500, 550, 'soldier')
                    );
                    
                    // Give them initial target info
                    setTimeout(() => {
                        for (const enemy of game.enemies) {
                            if (enemy.perception) {
                                enemy.perception.registerSound(game.player.x, game.player.y, 'footstep');
                            }
                        }
                    }, 100);
                    break;
                    
                case 'flank':
                    // Flanking maneuver
                    game.enemies.push(
                        window.AdvancedEnemyAI.createEnemy(500, 100, 'soldier'),
                        window.AdvancedEnemyAI.createEnemy(300, 200, 'assault'),
                        window.AdvancedEnemyAI.createEnemy(700, 200, 'assault')
                    );
                    break;
                    
                case 'siege':
                    // Surrounded
                    const positions = [
                        {x: 100, y: 100}, {x: 900, y: 100},
                        {x: 100, y: 500}, {x: 900, y: 500},
                        {x: 500, y: 50}, {x: 500, y: 550},
                        {x: 50, y: 300}, {x: 950, y: 300}
                    ];
                    
                    for (const pos of positions) {
                        const type = Math.random() < 0.3 ? 'sniper' : 
                                     Math.random() < 0.6 ? 'assault' : 'soldier';
                        game.enemies.push(
                            window.AdvancedEnemyAI.createEnemy(pos.x, pos.y, type)
                        );
                    }
                    break;
            }
        }
        
        function clearEnemies() {
            game.enemies = [];
        }
        
        function resetGame() {
            game.player = new Player(canvas.width / 2, canvas.height / 2);
            game.enemies = [];
            game.projectiles = [];
            game.particles = [];
            game.startTime = Date.now();
            createDefaultObstacles();
        }
        
        function togglePause() {
            game.paused = !game.paused;
            game.lastTime = Date.now();
        }
        
        function addObstacles() {
            // Add random obstacles
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * (canvas.width - 100) + 50;
                const y = Math.random() * (canvas.height - 100) + 50;
                const width = 30 + Math.random() * 50;
                const height = 30 + Math.random() * 50;
                
                game.obstacles.push(new Obstacle(x, y, width, height));
            }
        }
        
        // Event listeners
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            game.mouseX = e.clientX - rect.left;
            game.mouseY = e.clientY - rect.top;
        });
        
        canvas.addEventListener('click', (e) => {
            if (game.player) {
                game.player.shoot();
            }
        });
        
        window.addEventListener('keydown', (e) => {
            game.keys[e.key] = true;
        });
        
        window.addEventListener('keyup', (e) => {
            game.keys[e.key] = false;
        });
        
        document.getElementById('debugCheckbox').addEventListener('change', (e) => {
            window.DEBUG_AI = e.target.checked;
        });
        
        // Initialize
        initGame();
    </script>
</body>
</html>