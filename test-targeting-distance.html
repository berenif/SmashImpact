<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Targeting Distance Test</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            background: #000;
            border: 1px solid #333;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        
        button {
            margin: 5px;
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        #targetButton {
            position: absolute;
            right: 50px;
            bottom: 280px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(255, 50, 255, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.8);
            color: white;
            font-weight: bold;
            font-size: 12px;
            cursor: pointer;
        }
        
        #targetButton.disabled {
            background: rgba(100, 100, 100, 0.4);
            border-color: rgba(100, 100, 100, 0.6);
        }
        
        #targetButton.auto-disabled {
            background: rgba(200, 50, 50, 0.4);
            border-color: rgba(200, 100, 100, 0.6);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1280" height="720"></canvas>
    
    <div id="info">
        <div>Targeting Status: <span id="targetStatus">Loading...</span></div>
        <div>Current Target: <span id="currentTarget">None</span></div>
        <div>Distance to Target: <span id="targetDistance">N/A</span></div>
        <div>Auto-Disabled: <span id="autoDisabled">No</span></div>
        <div>Player Position: <span id="playerPos">0, 0</span></div>
    </div>
    
    <div id="controls">
        <button onclick="spawnEnemyNear()">Spawn Enemy Near</button>
        <button onclick="spawnEnemyFar()">Spawn Enemy Far</button>
        <button onclick="movePlayerAway()">Move Player Away</button>
        <button onclick="clearEnemies()">Clear Enemies</button>
    </div>
    
    <button id="targetButton" onclick="handleTargetButton()">TARGET</button>
    
    <script type="module">
        let engine = null;
        let canvas = null;
        let ctx = null;
        let animationId = null;
        let player = null;
        
        // Initialize the game
        async function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            try {
                // Load the WASM module
                const GameEngineModule = (await import('./public/game_engine.js')).default;
                const module = await GameEngineModule();
                
                // Create game engine
                engine = new module.GameEngine(canvas.width, canvas.height);
                
                // Create player at center
                player = engine.createPlayer(canvas.width / 2, canvas.height / 2);
                
                // Spawn a few enemies at different distances
                engine.createEnemy(canvas.width / 2 + 100, canvas.height / 2, 0);
                engine.createEnemy(canvas.width / 2 - 150, canvas.height / 2 + 100, 0);
                
                // Start game loop
                gameLoop();
                
                console.log('Game initialized successfully');
            } catch (error) {
                console.error('Failed to initialize game:', error);
                document.getElementById('targetStatus').textContent = 'Error: ' + error.message;
            }
        }
        
        // Game loop
        function gameLoop() {
            if (!engine) return;
            
            // Update engine
            engine.update(1/60);
            
            // Clear canvas
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Get entity positions
            const entities = engine.getEntityPositions();
            
            // Draw entities
            entities.forEach(entity => {
                ctx.save();
                
                // Choose color based on entity type
                if (entity.type === 0) { // Player
                    ctx.fillStyle = '#4CAF50';
                    player = entity;
                } else if (entity.type === 1 || entity.type === 2) { // Enemy
                    const targetId = engine.getCurrentTargetId();
                    if (entity.id === targetId) {
                        ctx.fillStyle = '#FF5722'; // Targeted enemy
                        
                        // Draw target indicator
                        ctx.strokeStyle = '#FF5722';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(entity.position.x, entity.position.y, entity.radius + 10, 0, Math.PI * 2);
                        ctx.stroke();
                    } else {
                        ctx.fillStyle = '#F44336'; // Normal enemy
                    }
                } else if (entity.type === 3) { // Obstacle
                    ctx.fillStyle = '#666';
                }
                
                // Draw entity
                ctx.beginPath();
                ctx.arc(entity.position.x, entity.position.y, entity.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw health bar for enemies
                if (entity.type === 1 || entity.type === 2) {
                    const healthPercent = entity.health / entity.maxHealth;
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.fillRect(entity.position.x - 20, entity.position.y - entity.radius - 10, 40, 4);
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                    ctx.fillRect(entity.position.x - 20, entity.position.y - entity.radius - 10, 40 * healthPercent, 4);
                }
                
                ctx.restore();
            });
            
            // Update UI
            updateUI();
            
            // Continue loop
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // Update UI elements
        function updateUI() {
            if (!engine) return;
            
            const targetingEnabled = engine.isTargetingEnabled();
            const autoDisabled = engine.isAutoDisabledDueToDistance();
            const targetId = engine.getCurrentTargetId();
            const buttonState = engine.getTargetButtonState();
            
            // Update status text
            document.getElementById('targetStatus').textContent = 
                autoDisabled ? 'Auto-Disabled (Too Far)' : 
                (targetingEnabled ? 'Enabled' : 'Disabled');
            
            document.getElementById('currentTarget').textContent = 
                targetId >= 0 ? `Enemy #${targetId}` : 'None';
            
            document.getElementById('autoDisabled').textContent = autoDisabled ? 'Yes' : 'No';
            
            // Update player position
            if (player) {
                document.getElementById('playerPos').textContent = 
                    `${Math.round(player.position.x)}, ${Math.round(player.position.y)}`;
                
                // Calculate distance to target
                if (targetId >= 0) {
                    const entities = engine.getEntityPositions();
                    const target = entities.find(e => e.id === targetId);
                    if (target) {
                        const dx = target.position.x - player.position.x;
                        const dy = target.position.y - player.position.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        document.getElementById('targetDistance').textContent = Math.round(distance);
                    }
                } else {
                    document.getElementById('targetDistance').textContent = 'N/A';
                }
            }
            
            // Update button appearance
            const button = document.getElementById('targetButton');
            button.className = '';
            if (autoDisabled) {
                button.className = 'auto-disabled';
                button.textContent = 'FAR';
            } else if (!targetingEnabled) {
                button.className = 'disabled';
                button.textContent = 'OFF';
            } else {
                button.textContent = 'TARGET';
            }
        }
        
        // Handle target button click
        window.handleTargetButton = function() {
            if (!engine) return;
            
            // Simulate a quick press (< 500ms)
            engine.handleTargetingButton(100);
        };
        
        // Spawn enemy near player
        window.spawnEnemyNear = function() {
            if (!engine || !player) return;
            
            const angle = Math.random() * Math.PI * 2;
            const distance = 100 + Math.random() * 100;
            const x = player.position.x + Math.cos(angle) * distance;
            const y = player.position.y + Math.sin(angle) * distance;
            
            engine.createEnemy(x, y, 0);
        };
        
        // Spawn enemy far from player
        window.spawnEnemyFar = function() {
            if (!engine || !player) return;
            
            const angle = Math.random() * Math.PI * 2;
            const distance = 600 + Math.random() * 200;
            const x = player.position.x + Math.cos(angle) * distance;
            const y = player.position.y + Math.sin(angle) * distance;
            
            engine.createEnemy(x, y, 0);
        };
        
        // Move player away from enemies
        window.movePlayerAway = function() {
            if (!engine || !player) return;
            
            // Apply velocity to move player
            engine.setPlayerVelocity(-200, -200);
            
            // Stop movement after a short time
            setTimeout(() => {
                engine.setPlayerVelocity(0, 0);
            }, 1000);
        };
        
        // Clear all enemies
        window.clearEnemies = function() {
            if (!engine) return;
            
            const entities = engine.getEntityPositions();
            entities.forEach(entity => {
                if (entity.type === 1 || entity.type === 2) {
                    // Note: We'd need a removeEntity method in the engine
                    // For now, we can damage them to death
                    for (let i = 0; i < 10; i++) {
                        engine.damageEntity(entity.id, 1000);
                    }
                }
            });
        };
        
        // Handle keyboard input
        document.addEventListener('keydown', (e) => {
            if (!engine) return;
            
            const speed = 300;
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                    engine.setPlayerVelocity(0, -speed);
                    break;
                case 'ArrowDown':
                case 's':
                    engine.setPlayerVelocity(0, speed);
                    break;
                case 'ArrowLeft':
                case 'a':
                    engine.setPlayerVelocity(-speed, 0);
                    break;
                case 'ArrowRight':
                case 'd':
                    engine.setPlayerVelocity(speed, 0);
                    break;
                case ' ':
                    handleTargetButton();
                    break;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (!engine) return;
            
            switch(e.key) {
                case 'ArrowUp':
                case 'ArrowDown':
                case 'ArrowLeft':
                case 'ArrowRight':
                case 'w':
                case 'a':
                case 's':
                case 'd':
                    engine.setPlayerVelocity(0, 0);
                    break;
            }
        });
        
        // Initialize on load
        init();
    </script>
</body>
</html>