<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>P2P LAN Webapp - Playable Tag</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    body { margin: 0; background:#0f1220; color:#e8ecff; display:grid; grid-template-columns: 360px 1fr; height: 100vh; }
    aside { border-right: 1px solid #2a2f4a; padding: 16px; overflow:auto; }
    main { display:grid; grid-template-rows: auto 1fr; }
    h1 { font-size: 18px; margin: 0 0 12px; }
    h2 { font-size: 15px; margin: 16px 0 8px; }
    .box { background:#151936; border:1px solid #2a2f4a; border-radius:12px; padding:12px; }
    textarea, input { width:100%; background:#0f1129; color:#e8ecff; border:1px solid #2a2f4a; border-radius:8px; padding:8px; }
    button { cursor:pointer; border:1px solid #2a2f4a; background:#1a1f3f; color:#e8ecff; border-radius:8px; padding:8px 10px; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    .row { display:flex; gap:8px; align-items:center; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .small { font-size: 12px; opacity:.9; }
    canvas { width:100%; height:100%; background:#0b0e1a; display:block; }
    .tag { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #2a2f4a; background:#121630; font-size:12px; }
    .ok { color:#00d084; }
    .warn { color:#ffc24b; }
    .bad { color:#ff4d4f; }
    .muted { color:#aab2ff; }
    .grid { display:grid; gap:10px; }
    .qr-modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.6);z-index:50}
    .qr-modal.show{display:flex}
    .qr-card{background:#151936;border:1px solid #2a2f4a;border-radius:12px;padding:16px;box-shadow:0 10px 40px rgba(0,0,0,.4)}
    .qr-hint{margin-top:8px}
    .qr-card video{width:360px;max-width:90vw;border-radius:8px;background:#000}
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; border:1px solid #2a2f4a; padding:0 6px; border-radius:6px; background:#101432; font-size:12px; }
  </style>
</head>
<body>
  <aside>
    <h1>P2P over LAN, pure browser</h1>
    <div class="small muted box" style="margin-bottom:10px">
      Two roles. Host creates an offer, peer pastes it and returns an answer. No server, copy paste or QR only. Same Wiâ€‘Fi is ideal.
    </div>

    <div class="grid">
      <section class="box">
        <h2>1) Host</h2>
        <div class="row" style="margin-bottom:8px">
          <button id="btnHostStart">Create Offer</button>
          <span id="hostState" class="tag">idle</span>
        </div>
        <label class="small">Offer to share</label>
        <textarea id="offerOut" class="mono" rows="6" readonly></textarea>
        <div class="row" style="margin:6px 0 10px">
          <button id="btnCopyOffer" disabled>Copy</button>
          <button id="btnQrOffer" disabled>Show QR</button>
        </div>
        <label class="small">Paste Answer from peer</label>
        <textarea id="answerIn" class="mono" rows="6" placeholder="Paste peer answer JSON here"></textarea>
        <div class="row" style="margin-top:6px">
          <button id="btnApplyAnswer" disabled>Apply Answer</button>
          <button id="btnScanAnswer">Scan QR</button>
        </div>
      </section>

      <section class="box">
        <h2>2) Peer</h2>
        <div class="row" style="margin-bottom:8px">
          <button id="btnPeerStart">Accept Offer</button>
          <span id="peerState" class="tag">idle</span>
        </div>
        <label class="small">Paste Offer from host</label>
        <textarea id="offerIn" class="mono" rows="6" placeholder="Paste host offer JSON here"></textarea>
        <div class="row" style="margin:6px 0 10px">
          <button id="btnApplyOffer" disabled>Apply Offer</button>
          <button id="btnScanOffer">Scan QR</button>
        </div>
        <label class="small">Answer to return</label>
        <textarea id="answerOut" class="mono" rows="6" readonly></textarea>
        <div class="row" style="margin-top:6px">
          <button id="btnCopyAnswer" disabled>Copy</button>
          <button id="btnQrAnswer" disabled>Show QR</button>
        </div>
      </section>

      <section class="box">
        <h2>Status</h2>
        <div class="small mono" id="status">Not connected</div>
        <div class="small mono" id="latency"></div>
      </section>

      <section class="box">
        <h2>Chat, debug</h2>
        <div class="row">
          <input id="chatInput" placeholder="Type a message" />
          <button id="chatSend" disabled>Send</button>
        </div>
        <pre id="log" class="small mono" style="white-space:pre-wrap"></pre>
      </section>

      <section class="box">
        <h2>Diagnostics</h2>
        <div class="row">
          <button id="btnRunTests">Run checks</button>
          <span class="small muted">Quick sanity tests log below</span>
        </div>
      </section>

      <section class="box">
        <h2>How to play</h2>
        <div class="small muted">
          Simple tag. Move with <span class="kbd">WASD</span> or arrows. If you are IT and touch the other player you score and roles swap. First to 10 wins or highest score when the timer ends.
        </div>
      </section>
    </div>
  </aside>

  <main>
    <div class="row" style="padding:10px; gap:16px; align-items:center; border-bottom:1px solid #2a2f4a;">
      <div>Game</div>
      <div class="small muted">You are <span id="meTag" class="tag">not joined</span>, move with WASD or arrows</div>
      <div class="row" style="margin-left:auto; gap:8px">
        <button id="btnStartGame" disabled>Start</button>
        <button id="btnResetGame" disabled>Reset</button>
      </div>
    </div>
    <canvas id="game"></canvas>

    <div id="qrModal" class="qr-modal">
      <div class="qr-card">
        <canvas id="qrCanvas" width="360" height="360"></canvas>
        <div class="row qr-hint" style="justify-content:space-between">
          <span class="small muted">Scan with your camera, copy the text</span>
          <button id="qrClose">Close</button>
        </div>
      </div>
    </div>
    <div id="scanModal" class="qr-modal">
      <div class="qr-card">
        <video id="scanVideo" autoplay playsinline muted></video>
        <div class="row qr-hint" style="justify-content:space-between">
          <span class="small muted">Point at QR. It will auto-fill.</span>
          <button id="scanClose">Close</button>
        </div>
      </div>
    </div>
  </main>

<script>
(function(){
  var qrcode=function(typeNumber, errorCorrectLevel){
    var PAD0=0xEC, PAD1=0x11;
    var _typeNumber=typeNumber,_errorCorrectLevel=QRErrorCorrectLevel[errorCorrectLevel],_modules=null,_moduleCount=0,_dataList=[],_dataCache=null;
    var makeImpl=function(test,maskPattern){_moduleCount=_typeNumber?(_typeNumber*4+17):(40*4+17);_modules=new Array(_moduleCount);for(var r=0;r<_moduleCount;r++){_modules[r]=new Array(_moduleCount);for(var c=0;c<_moduleCount;c++)_modules[r][c]=null}setupPositionProbePattern(0,0);setupPositionProbePattern(_moduleCount-7,0);setupPositionProbePattern(0,_moduleCount-7);setupTimingPattern();setupTypeInfo(test,maskPattern);if(_typeNumber>=7)setupTypeNumber(test);var data=createData(getBestRSBlocks(_typeNumber,_errorCorrectLevel),_dataList);mapData(data,maskPattern)};
    var setupPositionProbePattern=function(row,col){for(var r=-1;r<=7;r++){if(row+r<=-1||_moduleCount<=row+r)continue;for(var c=-1;c<=7;c++){if(col+c<=-1||_moduleCount<=col+c)continue;_modules[row+r][col+c]= (0<=r&&r<=6&&(c==0||c==6))||(0<=c&&c<=6&&(r==0||r==6))||(2<=r&&r<=4&&2<=c&&c<=4);}}};
    var setupTimingPattern=function(){for(var r=8;r<_moduleCount-8;r++){if(_modules[r][6]==null)_modules[r][6]=(r%2==0);}for(var c=8;c<_moduleCount-8;c++){if(_modules[6][c]==null)_modules[6][c]=(c%2==0);}};
    var setupTypeNumber=function(test){var bits=QRUtil.getBCHTypeNumber(_typeNumber);for(var i=0;i<18;i++){_modules[Math.floor(i/3)][i%3+_moduleCount-11]=!test&&((bits>>(17-i))&1)==1;_modules[i%3+_moduleCount-11][Math.floor(i/3)]=!test&&((bits>>(17-i))&1)==1}};
    var setupTypeInfo=function(test,maskPattern){var data=(_errorCorrectLevel<<3)|maskPattern;var bits=QRUtil.getBCHTypeInfo(data);for(var i=0;i<15;i++){var mod=((bits>>i)&1)==1;if(i<6){_modules[i][8]=!test&&mod;}else if(i<8){_modules[i+1][8]=!test&&mod;}else{_modules[_moduleCount-15+i][8]=!test&&mod;}}for(i=0;i<15;i++){mod=((bits>>i)&1)==1;if(i<8){_modules[8][_moduleCount-i-1]=!test&&mod;}else if(i<9){_modules[8][15-i-1]=!test&&mod;}else{_modules[8][14-i-1]=!test&&mod;}}_modules[_moduleCount-8][8]=!test};
    var mapData=function(data,maskPattern){var inc=-1;var row=_moduleCount-1;var bitIndex=7;var byteIndex=0;for(var col=_moduleCount-1;col>0;col-=2){if(col==6)col--;while(true){for(var c=0;c<2;c++){if(_modules[row][col-c]==null){var dark=false;if(byteIndex<data.length){dark=((data[byteIndex]>>>bitIndex)&1)==1;}if(QRUtil.getMask(maskPattern,row,col-c)){dark=!dark;}_modules[row][col-c]=dark;bitIndex--;if(bitIndex==-1){byteIndex++;bitIndex=7;}}}
          row+=inc;if(row<0||_moduleCount<=row){row-=inc;inc=-inc;break;}}}};
    var putData=function(data){_dataList.push(new QR8bitByte(data));_dataCache=null};
    var make=function(){if(_typeNumber<1)_typeNumber=getBestTypeNumber(_dataList,_errorCorrectLevel);if(_dataCache==null)_dataCache=createData(getBestRSBlocks(_typeNumber,_errorCorrectLevel),_dataList);makeImpl(false,getBestMaskPattern())};
    var getBestMaskPattern=function(){var min=0,pattern=0;for(var i=0;i<8;i++){makeImpl(true,i);var lost=QRUtil.getLostPoint({modules:_modules,moduleCount:_moduleCount});if(i==0||lost<min){min=lost;pattern=i;}}return pattern};
    var getModuleCount=function(){return _moduleCount};
    var isDark=function(r,c){return _modules[r][c]};
    return{addData:putData,make:make,getModuleCount:getModuleCount,isDark:isDark};
  };
  var QRMode={MODE_8BIT_BYTE:4};
  var QRErrorCorrectLevel={L:1,M:0,Q:3,H:2};
  var QRMaskPattern={PATTERN000:0,PATTERN001:1,PATTERN010:2,PATTERN011:3,PATTERN100:4,PATTERN101:5,PATTERN110:6,PATTERN111:7};
  var QRMath=function(){var EXP=new Array(256),LOG=new Array(256);for(var i=0;i<8;i++){EXP[i]=1<<i;}for(i=8;i<256;i++){EXP[i]=EXP[i-4]^EXP[i-5]^EXP[i-6]^EXP[i-8];}for(i=0;i<255;i++){LOG[EXP[i]]=i;}return{gexp:function(n){while(n<0)n+=255;while(n>=255)n-=255;return EXP[n];},glog:function(n){if(n<1)throw new Error('glog');return LOG[n];}}}();
  function QRPolynomial(num, shift){var offset=0;while(offset<num.length&&num[offset]==0)offset++;this.num=new Array(num.length-offset+shift);for(var i=0;i<num.length-offset;i++)this.num[i]=num[i+offset];}
  QRPolynomial.prototype.get=function(i){return this.num[i]};
  QRPolynomial.prototype.getLength=function(){return this.num.length};
  QRPolynomial.prototype.multiply=function(e){var num=new Array(this.getLength()+e.getLength()-1);for(var i=0;i<this.getLength();i++){for(var j=0;j<e.getLength();j++){num[i+j]^=QRMath.gexp(QRMath.glog(this.get(i))+QRMath.glog(e.get(j)));}}return new QRPolynomial(num,0)};
  QRPolynomial.prototype.mod=function(e){if(this.getLength()-e.getLength()<0)return this;var ratio=QRMath.glog(this.get(0))-QRMath.glog(e.get(0));var num=new Array(this.getLength());for(var i=0;i<this.getLength();i++){num[i]=this.get(i);}for(i=0;i<e.getLength();i++){num[i]^=QRMath.gexp(QRMath.glog(e.get(i))+ratio);}return new QRPolynomial(num,0).mod(e)};
  function QRRSBlock(totalCount,dataCount){this.totalCount=totalCount;this.dataCount=dataCount}
  var RS_BLOCK_TABLE = {};
  RS_BLOCK_TABLE[(QRErrorCorrectLevel.L<<8)+40] = [
    19, 148, 118,
     6, 149, 119
  ];
  function getBestRSBlocks(typeNumber,ec){if(typeNumber==0)typeNumber=40;var rs=RS_BLOCK_TABLE[(ec<<8)+typeNumber];var list=[];for(var i=0;i<rs.length/3;i++){var count=rs[i*3+0],total=rs[i*3+1],dc=rs[i*3+2];for(var j=0;j<count;j++){list.push(new QRRSBlock(total,dc));}}return list}
  var QRBitBuffer=function(){this.buffer=[];this.length=0};
  QRBitBuffer.prototype.get=function(i){return ((this.buffer[Math.floor(i/8)]>>> (7-i%8)) & 1)==1};
  QRBitBuffer.prototype.put=function(num,length){for(var i=0;i<length;i++)this.putBit(((num>>> (length-i-1))&1)==1)};
  QRBitBuffer.prototype.putBit=function(bit){this.buffer[Math.floor(this.length/8)]>>>=0;if(this.length%8==0)this.buffer.push(0);if(bit)this.buffer[Math.floor(this.length/8)]|=(0x80>>> (this.length%8));this.length++};
  var QRUtil=(function(){
    var PATTERN_POSITION_TABLE=[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,54,82,110,138],[6,30,56,84,112,140],[6,34,62,90,118,146],[6,30,58,86,114,142,170]];
    var G15=0x537,G18=0x1f25,G15_MASK=0x5412;
    function getBCHTypeInfo(data){var d=data<<10;while(getBCHDigit(d)-getBCHDigit(G15)>=0)d^=(G15<<(getBCHDigit(d)-getBCHDigit(G15)));return ((data<<10)|d)^G15_MASK}
    function getBCHTypeNumber(data){var d=data<<12;while(getBCHDigit(d)-getBCHDigit(G18)>=0)d^=(G18<<(getBCHDigit(d)-getBCHDigit(G18)));return (data<<12)|d}
    function getBCHDigit(data){var digit=0;while(data!=0){digit++;data>>>=1}return digit}
    function getMask(maskPattern,i,j){switch(maskPattern){case 0: return (i+j)%2==0; case 1: return i%2==0; case 2: return j%3==0; case 3: return (i+j)%3==0; case 4: return (Math.floor(i/2)+Math.floor(j/3))%2==0; case 5: return (i*j)%2+(i*j)%3==0; case 6: return ((i*j)%2+(i*j)%3)%2==0; case 7: return ((i*j)%3+(i+j)%2)%2==0; default: throw new Error('bad mask'); }}
    function getLostPoint(qr){
      var mc=qr.moduleCount,modules=qr.modules,lost=0;
      for(var r=0;r<mc;r++){
        for(var c=0;c<mc;c++){
          var same=0;var dark=modules[r][c];
          for(var rr=-1;rr<=1;rr++){
            if(r+rr<0||mc<=r+rr)continue;
            for(var cc=-1;cc<=1;cc++){
              if(c+cc<0||mc<=c+cc)continue;
              if(rr==0&&cc==0)continue;
              if(dark==modules[r+rr][c+cc])same++;
            }
          }
          if(same>5)lost+=(3+same-5)
        }
      }
      for(var r=0;r<mc;r++) for(var c=0;c<mc-6;c++){
        if(modules[r][c]&&!modules[r][c+1]&&modules[r][c+2]&&modules[r][c+3]&&modules[r][c+4]&&!modules[r][c+5]&&modules[r][c+6])lost+=40;
      }
      for(var c=0;c<mc;c++) for(var r=0;r<mc-6;r++){
        if(modules[r][c]&&!modules[r+1][c]&&modules[r+2][c]&&modules[r+3][c]&&modules[r+4][c]&&!modules[r+5][c]&&modules[r+6][c])lost+=40;
      }
      var darkCount=0;for(var r=0;r<mc;r++)for(var c=0;c<mc;c++)if(modules[r][c])darkCount++;
      var ratio=Math.abs(100*darkCount/mc/mc-50)/5;lost+=ratio*10;return lost;
    }
    return{getBCHTypeInfo:getBCHTypeInfo,getBCHTypeNumber:getBCHTypeNumber,getMask:getMask,getLostPoint:getLostPoint}
  })();
  function QR8bitByte(data){this.mode=QRMode.MODE_8BIT_BYTE;this.data=data}
  QR8bitByte.prototype.getLength=function(){return this.data.length};
  QR8bitByte.prototype.write=function(buffer){for(var i=0;i<this.data.length;i++)buffer.put(this.data.charCodeAt(i),8)};
  function getBestTypeNumber(list, ec){ return 40; }
  function createData(rsBlocks, dataList){var buffer=new QRBitBuffer();buffer.put(QRMode.MODE_8BIT_BYTE,4);var length=dataList[0].getLength();buffer.put(length,8);dataList[0].write(buffer);var totalDataCount=0;for(var i=0;i<rsBlocks.length;i++)totalDataCount+=rsBlocks[i].dataCount;while(buffer.length+4<=totalDataCount*8)buffer.put(0,4);while(buffer.length%8!=0)buffer.putBit(false);var data=[];for(i=0;i<buffer.buffer.length;i++)data.push(buffer.buffer[i]);return createBytes(data, rsBlocks)}
  function createBytes(buffer, rsBlocks){var offset=0;var maxDc=0;var maxEc=0;var dcdata=[];var ecdata=[];for(var r=0;r<rsBlocks.length;r++){var dcCount=rsBlocks[r].dataCount;var ecCount=rsBlocks[r].totalCount-dcCount;maxDc=Math.max(maxDc, dcCount);maxEc=Math.max(maxEc, ecCount);dcdata[r]=new Array(dcCount);for(var i=0;i<dcdata[r].length;i++){dcdata[r][i]=buffer[i+offset];}offset+=dcCount;var rsPoly=getErrorCorrectPolynomial(ecCount);var rawPoly=new QRPolynomial(dcdata[r],0);var modPoly=rawPoly.mod(rsPoly);ecdata[r]=new Array(ecCount);for(i=0;i<ecdata[r].length;i++){var modIndex=i+modPoly.getLength()-ecCount;ecdata[r][i]=(modIndex>=0)?modPoly.get(modIndex):0}}
  var totalCodeCount=0;for(r=0;r<rsBlocks.length;r++)totalCodeCount+=rsBlocks[r].totalCount;var data=[];for(i=0;i<totalCodeCount;i++)data.push(0);var index=0;for(i=0;i<maxDc;i++)for(r=0;r<rsBlocks.length;r++)if(i<dcdata[r].length)data[index++]=dcdata[r][i];for(i=0;i<maxEc;i++)for(r=0;r<rsBlocks.length;r++)if(i<ecdata[r].length)data[index++]=ecdata[r][i];return data}
  function getErrorCorrectPolynomial(ecLength){var a=new QRPolynomial([1],0);for(var i=0;i<ecLength;i++)a=a.multiply(new QRPolynomial([1, QRMath.gexp(i)],0));return a}

  window.qrcode = qrcode;
  window.QRErrorCorrectLevel = QRErrorCorrectLevel;
  window.RS_BLOCK_TABLE = RS_BLOCK_TABLE;
})();
</script>

<script type="module">
(() => {
  const el = id => document.getElementById(id);
  const clamp = (v,a,b) => Math.min(b, Math.max(a, v));
  const now = () => performance.now();

  const LZString=(function(){
    const keyStrBase64="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    const getBaseValue=(alphabet, character)=>alphabet.indexOf(character);
    const _compress=function(uncompressed, bitsPerChar, getCharFromInt){
      if(uncompressed==null) return ""; let i,value=0,context_dictionary={},context_dictionaryToCreate={},context_c="",context_wc="",context_w="",context_enlargeIn=2,context_dictSize=3,context_numBits=2,context_data=[],context_data_val=0,context_data_position=0;
      for(i=0;i<uncompressed.length;i+=1){ context_c=uncompressed.charAt(i); if(!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)){ context_dictionary[context_c]=context_dictSize++; context_dictionaryToCreate[context_c]=true; }
        context_wc=context_w+context_c; if(Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)){ context_w=context_wc; } else {
          if(Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)){
            let value=context_w.charCodeAt(0); for(let j=0;j<context_numBits;j++){ context_data_val=(context_data_val<<1); if(context_data_position==bitsPerChar-1){ context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; }
            for(let j=0;j<16;j++){ context_data_val=(context_data_val<<1)|((value>>j)&1); if(context_data_position==bitsPerChar-1){ context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; }
          } else { value=context_dictionary[context_w]; for(let j=0;j<context_numBits;j++){ context_data_val=(context_data_val<<1)| (value&1); if(context_data_position==bitsPerChar-1){ context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; value>>=1; }
          }
          context_enlargeIn--; if(context_enlargeIn==0){ context_enlargeIn=1<<context_numBits; context_numBits++; }
          context_dictionary[context_wc]=context_dictSize++; context_w=String(context_c);
        }
      }
      if(context_w!==''){
        if(Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)){
          let value=context_w.charCodeAt(0); for(let j=0;j<context_numBits;j++){ context_data_val=(context_data_val<<1); if(context_data_position==bitsPerChar-1){ context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; }
          for(let j=0;j<16;j++){ context_data_val=(context_data_val<<1)|((value>>j)&1); if(context_data_position==bitsPerChar-1){ context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; }
        } else { value=context_dictionary[context_w]; for(let j=0;j<context_numBits;j++){ context_data_val=(context_data_val<<1)| (value&1); if(context_data_position==bitsPerChar-1){ context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; value>>=1; }
        }
        context_enlargeIn--; if(context_enlargeIn==0){ context_enlargeIn=1<<context_numBits; context_numBits++; }
      }
      value=2; for(let j=0;j<context_numBits;j++){ context_data_val=(context_data_val<<1)| (value&1); if(context_data_position==bitsPerChar-1){ context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; value>>=1; }
      while(true){ context_data_val=(context_data_val<<1); if(context_data_position==bitsPerChar-1){ context_data.push(getCharFromInt(context_data_val)); break;} else context_data_position++; }
      return context_data.join('');
    };
    const _decompress=function(length, resetValue, getNextValue){ const dictionary=[], result=[], data={val:getNextValue(0),position=resetValue,index:1}; let enlargeIn=4, dictSize=4, numBits=3, entry, w, bits, resb, maxpower, power, c; function nextBits(n){ bits=0; maxpower=Math.pow(2,n); power=1; while(power!=maxpower){ resb=data.val & data.position; data.position >>=1; if(data.position==0){ data.position=resetValue; data.val=getNextValue(data.index++); } bits |= (resb>0?1:0)*power; power<<=1; } return bits; }
      for(let i=0;i<3;i++) dictionary[i]=i; bits=nextBits(2); switch(bits){case 0: c=String.fromCharCode(nextBits(16)); dictionary[3]=c; w=c; result.push(c); break; case 1: c=String.fromCharCode(nextBits(8)); dictionary[3]=c; w=c; result.push(c); break; case 2: return ""; }
      while(true){ if(data.index>length) return ""; bits=nextBits(numBits); let cc; switch(cc=bits){case 0: c=String.fromCharCode(nextBits(16)); dictionary[dictSize++]=c; enlargeIn--; if(enlargeIn==0){ enlargeIn=Math.pow(2,numBits); numBits++; } break; case 1: c=String.fromCharCode(nextBits(8)); dictionary[dictSize++]=c; enlargeIn--; if(enlargeIn==0){ enlargeIn=Math.pow(2,numBits); numBits++; } break; case 2: return result.join(''); default: }
        if(cc===0||cc===1) { w=c; result.push(c); continue; }
        let entryStr; if(bits<dictionary.length){ entryStr=dictionary[bits]; } else { if(bits===dictSize){ entryStr=w + w.charAt(0); } else { return ""; } }
        result.push(entryStr); dictionary[dictSize++]=w + entryStr.charAt(0); w=entryStr; enlargeIn--; if(enlargeIn==0){ enlargeIn=Math.pow(2,numBits); numBits++; }
      }
    };
    return {
      compressToBase64: function(input){ if(input==null) return ""; let res=_compress(input,6,function(a){return keyStrBase64.charAt(a)}); switch(res.length%4){default: case 0: return res; case 1: return res+"==="; case 2: return res+"=="; case 3: return res+"="; }
      },
      decompressFromBase64: function(input){ if(input==null) return ""; input=input.replace(/[^A-Za-z0-9\+\/\=]/g,""); return _decompress(input.length,32,function(index){ return getBaseValue(keyStrBase64,input.charAt(index)); }); }
    };
  })();
  const encodeForShare = (s) => 'z'+ LZString.compressToBase64(s);
  const decodeShared   = (s) => (s&&s[0]==='z') ? (LZString.decompressFromBase64(s.slice(1))||'') : s;

  const hostState = el('hostState');
  const peerState = el('peerState');
  const status = el('status');
  const latency = el('latency');
  const logEl = el('log');
  const meTag = el('meTag');
  const btnHostStart   = el('btnHostStart');
  const btnCopyOffer   = el('btnCopyOffer');
  const btnQrOffer     = el('btnQrOffer');
  const offerOut       = el('offerOut');
  const answerIn       = el('answerIn');
  const btnApplyAnswer = el('btnApplyAnswer');
  const btnScanAnswer  = el('btnScanAnswer');
  const btnPeerStart   = el('btnPeerStart');
  const offerIn        = el('offerIn');
  const btnApplyOffer  = el('btnApplyOffer');
  const btnScanOffer   = el('btnScanOffer');
  const answerOut      = el('answerOut');
  const btnCopyAnswer  = el('btnCopyAnswer');
  const btnQrAnswer    = el('btnQrAnswer');
  const qrModal  = el('qrModal');
  const qrCanvas = el('qrCanvas');
  const qrClose  = el('qrClose');
  const scanModal = el('scanModal');
  const scanVideo = el('scanVideo');
  const scanClose = el('scanClose');
  const chatInput = el('chatInput');
  const chatSend  = el('chatSend');
  const btnRunTests = el('btnRunTests');
  const btnStartGame = el('btnStartGame');
  const btnResetGame = el('btnResetGame');

  function log(msg){ logEl.textContent = `[${new Date().toLocaleTimeString()}] ${msg}\n` + logEl.textContent; }
  function setStatus(s, good){ status.textContent = s; status.className = 'small mono ' + (good ? 'ok' : 'muted'); }
  function setRoleTag(r){ meTag.textContent = r ? `${r} ready` : 'not joined'; }

  class Net {
    constructor(){ this.pc=null; this.dc=null; this.role=null; this.pingTimer=0; this.rtt=null; this.onopen=null; this.onclose=null; this.onmessage=null; }
    makePC(){ const rtcConfig = { iceServers: [] }; this.pc = new RTCPeerConnection(rtcConfig);
      this.pc.onconnectionstatechange = () => { const st=this.pc.connectionState; setStatus(`State: ${st}`, st === 'connected'); if(st==='failed') log('Connection failed, check network or HTTPS.'); };
      this.pc.onicecandidateerror = (e) => log('ICE error: ' + (e.errorText || e.hostCandidate || ''));
      return this.pc; }
    bindDC(channel){ this.dc = channel; chatSend.disabled = false;
      this.dc.onopen  = () => { setStatus('Connected', true); this.startPings(); if(this.onopen) this.onopen(); };
      this.dc.onclose = () => { setStatus('Disconnected', false); this.stopPings(); if(this.onclose) this.onclose(); };
      this.dc.onmessage = (e) => { try{ const msg = JSON.parse(e.data); if(msg.type==='ping'){ this.send({type:'pong', t:msg.t}); } else if(msg.type==='pong'){ this.rtt = Math.round(performance.now() - msg.t); latency.textContent = `RTT ~ ${this.rtt} ms`; } else { if(this.onmessage) this.onmessage(msg); } } catch (err) { log(`Raw: ${e.data}`); } };
    }
    startHost(){ this.role='host'; setRoleTag('host'); btnHostStart.disabled = true; btnPeerStart.disabled = true; hostState.textContent='creating';
      this.makePC(); const ch = this.pc.createDataChannel('game', { ordered:true }); this.bindDC(ch);
      return this.pc.createOffer().then(offer=>this.pc.setLocalDescription(offer)).then(()=>this.waitICE()).then(()=>{
        offerOut.value = JSON.stringify(this.pc.localDescription); btnCopyOffer.disabled = false; btnApplyAnswer.disabled = false; btnQrOffer.disabled = false; hostState.textContent='offer ready'; setStatus('Share offer with peer', false);
      });
    }
    startPeer(){ this.role='peer'; setRoleTag('peer'); btnPeerStart.disabled = true; btnHostStart.disabled = true; peerState.textContent='ready'; btnApplyOffer.disabled = false; }
    async applyOfferFromText(txt){ try{ if(this.role!=='peer'){ this.startPeer(); }
      this.makePC(); this.pc.ondatachannel = (e)=> this.bindDC(e.channel);
      const offer = JSON.parse(decodeShared(txt)); await this.pc.setRemoteDescription(offer);
      const answer = await this.pc.createAnswer(); await this.pc.setLocalDescription(answer); await this.waitICE();
      answerOut.value = JSON.stringify(this.pc.localDescription); btnCopyAnswer.disabled = false; btnQrAnswer.disabled = false; peerState.textContent ='answer ready'; setStatus('Send answer back to host', false);
    } catch(e){ log('Bad offer JSON'); } }
    async applyAnswerFromText(txt){ try{ const answer = JSON.parse(decodeShared(txt)); await this.pc.setRemoteDescription(answer); hostState.textContent='answer applied'; setStatus('Waiting for channel open', false); } catch(e){ log('Bad answer JSON'); } }
    send(obj){ if(this.dc && this.dc.readyState==='open'){ try{ this.dc.send(JSON.stringify(obj)); }catch(e){} } }
    startPings(){ this.stopPings(); this.pingTimer = setInterval(()=>{ this.send({type:'ping', t:performance.now()}); }, 1000); }
    stopPings(){ if(this.pingTimer){ clearInterval(this.pingTimer); this.pingTimer=0; } }
    async waitICE(){ if(this.pc.iceGatheringState==='complete') return; await new Promise(res=>{ const check=()=>{ if(this.pc.iceGatheringState==='complete'){ this.pc.removeEventListener('icegatheringstatechange', check); res(); } }; this.pc.addEventListener('icegatheringstatechange', check); }); }
  }

  const net = new Net();

  const canvas = el('game');
  const ctx = canvas.getContext('2d');
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let W = 960, H = 600; function resize(){ const rect = canvas.getBoundingClientRect(); W=Math.floor(rect.width*DPR); H=Math.floor(rect.height*DPR); canvas.width=W; canvas.height=H; } window.addEventListener('resize', resize); resize();

  const world = { w: 1600, h: 900 };
  const R = 22, SPEED = 360;
  const SCORE_TO_WIN = 10, ROUND_TIME = 120;
  const TAG_COOLDOWN = 800;

  const me   = { x: 200, y: 200, color: '#2bd27e', score:0, name:'you' };
  const them = { x: 600, y: 200, color: '#ff6262', score:0, name:'peer', tx:600, ty:200, lastUpdate:0 };

  let role = null;
  let game = { started:false, it:'me', tLeft: ROUND_TIME, lastTick: now(), lastTagAt: 0 };

  const keys = new Set();
  window.addEventListener('keydown', e => { if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'].includes(e.key)) { keys.add(e.key.toLowerCase()); e.preventDefault(); } });
  window.addEventListener('keyup', e => { keys.delete(e.key.toLowerCase()); });

  function moveLocal(dt){ let dx=0, dy=0; if(keys.has('arrowup')||keys.has('w')) dy-=1; if(keys.has('arrowdown')||keys.has('s')) dy+=1; if(keys.has('arrowleft')||keys.has('a')) dx-=1; if(keys.has('arrowright')||keys.has('d')) dx+=1; if(dx||dy){ const m=Math.hypot(dx,dy)||1; me.x=clamp(me.x+dx/m*SPEED*dt, R, world.w-R); me.y=clamp(me.y+dy/m*SPEED*dt, R, world.h-R); sendThrottled({ type:'pos', x:me.x, y:me.y }); } }

  function updateRemote(dt){ const lerp = (a,b,t)=>a+(b-a)*t; const LERP_SPD = 10; them.x = lerp(them.x, them.tx, Math.min(1, LERP_SPD*dt)); them.y = lerp(them.y, them.ty, Math.min(1, LERP_SPD*dt)); }

  function hostTick(dt){ if(!game.started) return; game.tLeft = Math.max(0, game.tLeft - dt); if(game.tLeft===0) endRound();
    const canTag = (now() - game.lastTagAt) > TAG_COOLDOWN;
    if(canTag){ const dx = me.x - them.x, dy = me.y - them.y; const touching = Math.hypot(dx,dy) <= R*2; if(touching){ if(game.it==='me'){ me.score++; game.it='peer'; game.lastTagAt = now(); broadcastState(); checkWin(); } else if(game.it==='peer'){ them.score++; game.it='me'; game.lastTagAt = now(); broadcastState(); checkWin(); } } }
    snapshotTimer -= dt; if(snapshotTimer<=0){ snapshotTimer = 0.2; broadcastState(); }
  }

  function checkWin(){ if(me.score>=SCORE_TO_WIN || them.score>=SCORE_TO_WIN){ endRound(); } }

  function endRound(){ game.started=false; broadcastState(); }

  function draw(){ const cx=(me.x+them.x)/2, cy=(me.y+them.y)/2; const scale = Math.min(W/world.w, H/world.h); const vw=W/scale, vh=H/scale; const camX=clamp(cx - vw/2, 0, Math.max(0, world.w - vw)); const camY=clamp(cy - vh/2, 0, Math.max(0, world.h - vh)); ctx.save(); ctx.scale(scale, scale); ctx.clearRect(0,0,vw,vh); ctx.fillStyle='#0b0e1a'; ctx.fillRect(0,0,vw,vh);
    ctx.strokeStyle='#1e2447'; ctx.lineWidth=1; for(let x=0;x<world.w;x+=80){ line(x - camX, 0 - camY, x - camX, world.h - camY); } for(let y=0;y<world.h;y+=80){ line(0 - camX, y - camY, world.w - camX, y - camY); }
    drawPlayer(me, camX, camY, game.it==='me');
    drawPlayer(them, camX, camY, game.it==='peer');
    ctx.fillStyle='#e8ecff'; ctx.font='16px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial'; ctx.textAlign='left';
    const tText = `Time ${Math.ceil(game.tLeft)}s`; ctx.fillText(tText, 12 - camX, 24 - camY);
    ctx.fillText(`You ${me.score}`, 12 - camX, 46 - camY);
    ctx.fillText(`Peer ${them.score}`, 12 - camX, 68 - camY);
    ctx.textAlign='center'; ctx.font='18px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    const roleText = game.started ? (game.it==='me' ? 'You are IT' : 'You are running') : 'Press Start';
    ctx.fillText(roleText, (vw/2), 28 - camY);
    ctx.restore(); }

  function line(x1,y1,x2,y2){ ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); }
  function drawPlayer(p, camX, camY, isIT){ ctx.beginPath(); ctx.arc(p.x - camX, p.y - camY, R, 0, Math.PI*2); ctx.fillStyle = p.color; ctx.fill(); if(isIT){ ctx.strokeStyle='#ffd24e'; ctx.lineWidth=3; ctx.stroke(); } }

  let lastTS = now(); let snapshotTimer = 0.2;
  function loop(ts){ const dt = Math.min(0.05, (ts - lastTS)/1000); lastTS = ts; moveLocal(dt); updateRemote(dt); if(role==='host') hostTick(dt); draw(); requestAnimationFrame(loop); }
  requestAnimationFrame(loop);

  net.onopen = () => { btnStartGame.disabled = (net.role!=='host'); btnResetGame.disabled = (net.role!=='host'); if(net.role==='host'){
      me.x=200; me.y=200; them.x=1400; them.y=700; them.tx=them.x; them.ty=them.y; me.score=0; them.score=0; game={ started:false, it: Math.random()<0.5? 'me':'peer', tLeft: ROUND_TIME, lastTick: now(), lastTagAt: 0 }; broadcastState(); }
  };
  net.onclose = () => { btnStartGame.disabled = true; btnResetGame.disabled = true; };
  net.onmessage = (msg) => { if(msg.type==='pos'){ them.tx = clamp(msg.x, R, world.w-R); them.ty = clamp(msg.y, R, world.h-R); them.lastUpdate = now(); }
    else if(msg.type==='state'){ applyState(msg.state); }
    else if(msg.type==='chat'){ log(`Peer: ${msg.text}`); }
  };

  function broadcastState(){ if(net.role==='host'){ const state = { me:{x:me.x,y:me.y,score:me.score}, them:{x:them.x,y:them.y,score:them.score}, started:game.started, it:game.it, tLeft:Math.ceil(game.tLeft) }; net.send({ type:'state', state: state }); } }
  function applyState(s){
    if(net.role==='peer'){
      me.x = s.them.x; me.y = s.them.y; me.score = s.them.score;
      them.tx = s.me.x; them.ty = s.me.y; them.score = s.me.score;
      game.started = s.started; game.it = (s.it==='me') ? 'peer' : 'me'; game.tLeft = s.tLeft; }
    else {
      me.x = s.me.x; me.y = s.me.y; me.score = s.me.score; them.tx = s.them.x; them.ty = s.them.y; them.score = s.them.score; game.started = s.started; game.it = s.it; game.tLeft = s.tLeft; }
  }

  let lastSend = 0; function sendThrottled(obj){ const t=now(); if(t - lastSend > 33){ net.send(obj); lastSend = t; } }

  btnHostStart.onclick = async () => { role='host'; net.role='host'; await net.startHost(); };
  btnPeerStart.onclick = () => { role='peer'; net.startPeer(); };
  btnCopyOffer.onclick = async () => { await navigator.clipboard.writeText(encodeForShare(offerOut.value)); btnCopyOffer.textContent='Copied'; setTimeout(()=>btnCopyOffer.textContent='Copy', 800); };
  btnCopyAnswer.onclick = async () => { await navigator.clipboard.writeText(encodeForShare(answerOut.value)); btnCopyAnswer.textContent='Copied'; setTimeout(()=>btnCopyAnswer.textContent='Copy', 800); };

  async function applyAnswerFromText(txt){ await net.applyAnswerFromText(txt); }
  async function applyOfferFromText(txt){ await net.applyOfferFromText(txt); }
  btnApplyAnswer.onclick = async ()=>{ await applyAnswerFromText(answerIn.value); };
  btnApplyOffer.onclick  = async ()=>{ await applyOfferFromText(offerIn.value); };

  btnStartGame.onclick = () => { if(net.role!=='host') return; game.started=true; game.tLeft = ROUND_TIME; game.lastTagAt = 0; broadcastState(); };
  btnResetGame.onclick = () => { if(net.role!=='host') return; me.x=200; me.y=200; them.x=1400; them.y=700; them.tx=them.x; them.ty=them.y; me.score=0; them.score=0; game.started=false; game.it = Math.random()<0.5 ? 'me' : 'peer'; game.tLeft = ROUND_TIME; broadcastState(); };

  chatSend.onclick = () => { const text = chatInput.value.trim(); if(!text) return; net.send({ type:'chat', text: text }); log('You: ' + text); chatInput.value=''; };
  chatInput.addEventListener('keydown', e => { if (e.key === 'Enter') chatSend.click(); });

  function drawQrToCanvas(text, canvas, scale){ var qr = qrcode(0, 'L'); qr.addData(text); qr.make(); var count = qr.getModuleCount(); var size = count * scale; canvas.width = canvas.height = Math.max(240, size); var ctx2 = canvas.getContext('2d'); ctx2.fillStyle = '#fff'; ctx2.fillRect(0,0,canvas.width,canvas.height); var offset = Math.floor((canvas.width - size)/2); for(var r=0;r<count;r++){ for(var c=0;c<count;c++){ ctx2.fillStyle = qr.isDark(r,c)? '#000':'#fff'; ctx2.fillRect(offset + c*scale, offset + r*scale, scale, scale); } } }
  function showQR(text){ try{ drawQrToCanvas(encodeForShare(text), qrCanvas, 8); qrModal.classList.add('show'); } catch(e){ log('QR error: ' + e.message); } }
  btnQrOffer.onclick  = () => { if(!offerOut.value) return; showQR(offerOut.value); };
  btnQrAnswer.onclick = () => { if(!answerOut.value) return; showQR(answerOut.value); };
  qrClose.onclick     = () => { qrModal.classList.remove('show'); };

  let scanStream=null; let scanRunning=false; let detector=null;
  async function startScan(targetField){ try{
      if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
        alert('Camera requires HTTPS or localhost. Use copy paste if not available.'); return; }
      if (!('BarcodeDetector' in window)) { log('QR scan unsupported in this browser'); alert('QR scanning not supported here. Use copy paste instead.'); return; }
      detector = new BarcodeDetector({ formats:['qr_code'] }); scanModal.classList.add('show');
      scanStream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'environment' }, audio:false }); scanVideo.srcObject = scanStream; await scanVideo.play(); scanRunning=true;
      const loop = async ()=>{ if(!scanRunning) return; try{ const codes = await detector.detect(scanVideo); if(codes && codes.length){ const raw = codes[0].rawValue || ''; if(raw){ targetField.value = raw; stopScan(); if (targetField === offerIn) { await applyOfferFromText(raw); } else if (targetField === answerIn) { await applyAnswerFromText(raw); } return; } } } catch (err) {} requestAnimationFrame(loop); };
      requestAnimationFrame(loop);
    }catch(e){ log('Camera error: ' + e.message); alert('Camera access failed. Check permissions.'); stopScan(); }
  }
  function stopScan(){ scanRunning=false; if(scanStream){ scanStream.getTracks().forEach(t=>t.stop()); scanStream=null; } scanModal.classList.remove('show'); }
  btnScanOffer.onclick  = () => startScan(offerIn);
  btnScanAnswer.onclick = () => startScan(answerIn);
  scanClose.onclick     = () => stopScan();

  btnRunTests.onclick = () => {
    const results = []; const ok=(name,cond)=>results.push(`${cond? 'âœ…':'âŒ'} ${name}`);
    try { const q = qrcode(0, 'L'); q.addData('test'); q.make(); ok('QR encode short text', q.getModuleCount() > 0); } catch(e){ ok('QR encode short text', false); log('QR test error: '+e.message); }
    try { const tmp = document.createElement('canvas'); drawQrToCanvas(encodeForShare('hello'), tmp, 4); ok('drawQrToCanvas runs', tmp.width > 0); } catch(e){ ok('drawQrToCanvas runs', false); log('drawQrToCanvas error: '+e.message); }
    ok('RTCPeerConnection present', !!window.RTCPeerConnection);
    ok('BarcodeDetector present (optional)', 'BarcodeDetector' in window);
    ok('#btnQrOffer single element', document.querySelectorAll('#btnQrOffer').length === 1);
    ok('#btnQrAnswer single element', document.querySelectorAll('#btnQrAnswer').length === 1);
    try { const s='{"a":1}'; const enc=encodeForShare(s); const dec=decodeShared(enc); ok('Compression roundtrip', dec===s && enc.startsWith('z')); } catch(e){ ok('Compression roundtrip', false); }
    try { const s2='{"b":2}'; ok('decodeShared raw passthrough', decodeShared(s2)===s2); } catch(e){ ok('decodeShared raw passthrough', false); }
    try { ok('RS table present', typeof RS_BLOCK_TABLE==='object' && !!RS_BLOCK_TABLE[(QRErrorCorrectLevel.L<<8)+40]); } catch(e){ ok('RS table present', false); }
    try { const big = JSON.stringify({ s: 'x'.repeat(2000) }); const enc=encodeForShare(big); const dec=decodeShared(enc); ok('Large compression roundtrip', dec===big); ok('Large compression shrinks', enc.length < big.length); } catch(e){ ok('Large compression roundtrip', false); }
    try { const s3=''; const enc3=encodeForShare(s3); const dec3=decodeShared(enc3); ok('Empty string roundtrip', dec3===s3 && enc3.startsWith('z')); } catch(e){ ok('Empty string roundtrip', false); }
    try { const st={ started:false, it:'me', tLeft:60, lastTick:0, lastTagAt:0 }; ok('Game state shape', typeof st.it==='string' && typeof st.tLeft==='number'); } catch(e){ ok('Game state shape', false); }
    try { const snap={ me:{x:1,y:2,score:0}, them:{x:3,y:4,score:0}, started:true, it:'me', tLeft:100 }; ok('State snapshot object', !!snap.me && !!snap.them && typeof snap.started==='boolean'); } catch(e){ ok('State snapshot object', false); }
    ok('Secure origin for camera', location.protocol==='https:' || location.hostname==='localhost' || location.hostname==='127.0.0.1');
    try { const t='{"t":"Ã©ðŸ˜Š"}'; const enc=encodeForShare(t); const dec=decodeShared(enc); ok('Unicode roundtrip', dec===t); } catch(e){ ok('Unicode roundtrip', false); }
    try { const enc=encodeForShare('{"k":1}'); ok('Share prefix', enc[0]==='z'); ok('Base64 charset', /^[A-Za-z0-9+/=]+$/.test(enc.slice(1))); } catch(e){ ok('Base64 charset', false); }
    try { const state={ me:{x:1,y:2,score:0}, them:{x:3,y:4,score:0}, started:false, it:'me', tLeft:10 }; const copy=JSON.parse(JSON.stringify(state)); ok('State JSON roundtrip', copy.me.x===1 && copy.it==='me'); } catch(e){ ok('State JSON roundtrip', false); }
    try { const obj = { type:'x', state:{ n:1 } }; const s = JSON.stringify(obj); ok('Object literal serializes', /\{"type":"x","state":\{"n":1\}\}/.test(s)); } catch(e){ ok('Object literal serializes', false); }
    log(results.join('\n'));
  };
})();
</script>
</body>
</html>
