<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="format-detection" content="telephone=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <title>P2P LAN Webapp - Playable Tag</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    body { margin: 0; background:#0f1220; color:#e8ecff; display:grid; grid-template-columns: 360px 1fr; height: 100vh; }
    aside { border-right: 1px solid #2a2f4a; padding: 16px; overflow:auto; }
    main { display:grid; grid-template-rows: auto 1fr; }
    h1 { font-size: 18px; margin: 0 0 12px; }
    h2 { font-size: 15px; margin: 16px 0 8px; }
    .box { background:#151936; border:1px solid #2a2f4a; border-radius:12px; padding:12px; }
    textarea, input { width:100%; background:#0f1129; color:#e8ecff; border:1px solid #2a2f4a; border-radius:8px; padding:8px; }
    button { cursor:pointer; border:1px solid #2a2f4a; background:#1a1f3f; color:#e8ecff; border-radius:8px; padding:8px 10px; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    .row { display:flex; gap:8px; align-items:center; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .small { font-size: 12px; opacity:.9; }
    canvas { width:100%; height:100%; background:#0b0e1a; display:block; }
    .tag { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #2a2f4a; background:#121630; font-size:12px; }
    .ok { color:#00d084; }
    .warn { color:#ffc24b; }
    .bad { color:#ff4d4f; }
    .muted { color:#aab2ff; }
    .grid { display:grid; gap:10px; }
    .qr-modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.6);z-index:50}
    .qr-modal.show{display:flex}
    .qr-card{background:#151936;border:1px solid #2a2f4a;border-radius:12px;padding:16px;box-shadow:0 10px 40px rgba(0,0,0,.4)}
    .qr-hint{margin-top:8px}
    .qr-card video{width:360px;max-width:90vw;border-radius:8px;background:#000}
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; border:1px solid #2a2f4a; padding:0 6px; border-radius:6px; background:#101432; font-size:12px; }
    
    /* Cross-browser compatibility improvements */
    * { box-sizing: border-box; }
    
    /* Fallback for browsers that don't support CSS Grid */
    @supports not (display: grid) {
      body { display: flex; }
      aside { flex: 0 0 360px; }
      main { flex: 1; display: flex; flex-direction: column; }
    }
    
    /* Vendor prefixes for better browser support */
    button { 
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    
    textarea, input { 
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
    }
    
    /* Smooth scrolling for better UX */
    html { scroll-behavior: smooth; }
    
    /* Better focus indicators for accessibility */
    button:focus, textarea:focus, input:focus { 
      outline: 2px solid #4a9eff; 
      outline-offset: 2px;
    }
    
    /* High contrast mode support */
    @media (prefers-contrast: high) {
      .box { border-width: 2px; }
      button { border-width: 2px; }
    }
    
    /* Reduced motion support */
    @media (prefers-reduced-motion: reduce) {
      * { animation-duration: 0.01ms !important; animation-iteration-count: 1 !important; transition-duration: 0.01ms !important; }
    }
  </style>
</head>
<body>
  <aside>
    <h1>P2P over LAN, pure browser</h1>
    <div class="small muted box" style="margin-bottom:10px">
      Two roles. Host creates an offer, peer pastes it and returns an answer. No server, copy paste or QR only. Same Wiâ€‘Fi is ideal.
    </div>

    <div class="grid">
      <section class="box">
        <h2>1) Host</h2>
        <div class="row" style="margin-bottom:8px">
          <button id="btnHostStart">Create Offer</button>
          <span id="hostState" class="tag">idle</span>
        </div>
        <label class="small">Offer to share</label>
        <textarea id="offerOut" class="mono" rows="6" readonly></textarea>
        <div class="row" style="margin:6px 0 10px">
          <button id="btnCopyOffer" disabled>Copy</button>
          <button id="btnQrOffer" disabled>Show QR</button>
        </div>
        <label class="small">Paste Answer from peer</label>
        <textarea id="answerIn" class="mono" rows="6" placeholder="Paste peer answer JSON here"></textarea>
        <div class="row" style="margin-top:6px">
          <button id="btnApplyAnswer" disabled>Apply Answer</button>
          <button id="btnScanAnswer">Scan QR</button>
        </div>
      </section>

      <section class="box">
        <h2>2) Peer</h2>
        <div class="row" style="margin-bottom:8px">
          <button id="btnPeerStart">Accept Offer</button>
          <span id="peerState" class="tag">idle</span>
        </div>
        <label class="small">Paste Offer from host</label>
        <textarea id="offerIn" class="mono" rows="6" placeholder="Paste host offer JSON here"></textarea>
        <div class="row" style="margin:6px 0 10px">
          <button id="btnApplyOffer" disabled>Apply Offer</button>
          <button id="btnScanOffer">Scan QR</button>
        </div>
        <label class="small">Answer to return</label>
        <textarea id="answerOut" class="mono" rows="6" readonly></textarea>
        <div class="row" style="margin-top:6px">
          <button id="btnCopyAnswer" disabled>Copy</button>
          <button id="btnQrAnswer" disabled>Show QR</button>
        </div>
      </section>

      <section class="box">
        <h2>Status</h2>
        <div class="small mono" id="status">Not connected</div>
        <div class="small mono" id="latency"></div>
      </section>

      <section class="box">
        <h2>Chat, debug</h2>
        <div class="row">
          <input id="chatInput" placeholder="Type a message" />
          <button id="chatSend" disabled>Send</button>
        </div>
        <pre id="log" class="small mono" style="white-space:pre-wrap"></pre>
      </section>

      <section class="box">
        <h2>Diagnostics</h2>
        <div class="row">
          <button id="btnRunTests">Run checks</button>
          <span class="small muted">Quick sanity tests log below</span>
        </div>
      </section>

      <section class="box">
        <h2>How to play</h2>
        <div class="small muted">
          Simple tag. Move with <span class="kbd">WASD</span> or arrows. If you are IT and touch the other player you score and roles swap. First to 10 wins or highest score when the timer ends.
        </div>
      </section>
    </div>
  </aside>

  <main>
    <div class="row" style="padding:10px; gap:16px; align-items:center; border-bottom:1px solid #2a2f4a;">
      <div>Game</div>
      <div class="small muted">You are <span id="meTag" class="tag">not joined</span>, move with WASD or arrows</div>
      <div class="row" style="margin-left:auto; gap:8px">
        <button id="btnStartGame" disabled>Start</button>
        <button id="btnResetGame" disabled>Reset</button>
      </div>
    </div>
    <canvas id="game"></canvas>

    <div id="qrModal" class="qr-modal">
      <div class="qr-card">
        <canvas id="qrCanvas" width="360" height="360"></canvas>
        <div class="row qr-hint" style="justify-content:space-between">
          <span class="small muted">Scan with your camera, copy the text</span>
          <button id="qrClose">Close</button>
        </div>
      </div>
    </div>
    <div id="scanModal" class="qr-modal">
      <div class="qr-card">
        <video id="scanVideo" autoplay playsinline muted></video>
        <div class="row qr-hint" style="justify-content:space-between">
          <span class="small muted">Point at QR. It will auto-fill.</span>
          <button id="scanClose">Close</button>
        </div>
      </div>
    </div>
  </main>

<script src="./vendor/qrcode.js"></script>

<script>
// Ensure QR library is loaded before proceeding
// Wait a bit for the script to load and initialize
setTimeout(() => {
  if (typeof window.qrcode !== 'function') {
    console.error('QR library failed to load');
    // Fallback QR implementation
    window.qrcode = function(typeNumber, errorCorrectLevel) {
      console.warn('Using fallback QR implementation');
      return {
        addData: function(data) { this.data = data; },
        make: function() { this.made = true; },
        getModuleCount: function() { return 21; },
        isDark: function(row, col) { 
          // Simple fallback pattern
          return (row + col) % 2 === 0; 
        }
      };
    };
  } else {
    console.log('QR library loaded successfully');
  }
}, 100);

// Browser compatibility checks and polyfills
function checkBrowserCompatibility() {
  const issues = [];
  
  // Check WebRTC support
  if (!window.RTCPeerConnection && !window.webkitRTCPeerConnection && !window.mozRTCPeerConnection) {
    issues.push('WebRTC not supported - RTCPeerConnection missing');
  }
  
  // Check canvas support
  if (!document.createElement('canvas').getContext) {
    issues.push('Canvas not supported');
  }
  
  // Check for modern JavaScript features
  if (!window.Promise) {
    issues.push('Promises not supported');
  }
  
  // Check for performance.now() with fallback
  if (!window.performance || !window.performance.now) {
    window.performance = window.performance || {};
    window.performance.now = window.performance.now || function() {
      return Date.now();
    };
  }
  
  // Check for requestAnimationFrame with fallback
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = window.requestAnimationFrame || function(callback) {
      return setTimeout(callback, 1000 / 60);
    };
    window.cancelAnimationFrame = window.cancelAnimationFrame || function(id) {
      clearTimeout(id);
    };
  }
  
  // Check for devicePixelRatio
  if (!window.devicePixelRatio) {
    window.devicePixelRatio = 1;
  }
  
  if (issues.length > 0) {
    const warning = document.createElement('div');
    warning.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#ff4d4f;color:white;padding:10px;text-align:center;z-index:1000;font-family:system-ui;';
    warning.innerHTML = '<strong>Browser Compatibility Issues:</strong> ' + issues.join(', ');
    document.body.appendChild(warning);
  }
}

// Run compatibility check after DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', checkBrowserCompatibility);
} else {
  checkBrowserCompatibility();
}

// Add error handling for unhandled promise rejections
window.addEventListener('unhandledrejection', function(event) {
  console.error('Unhandled promise rejection:', event.reason);
  // Optionally show user-friendly error message
});

// Add error handling for global errors
window.addEventListener('error', function(event) {
  console.error('Global error:', event.error);
});
</script>

<script type="module" src="./src/main.js"></script>
<script type="module">
(() => { return;
  const el = id => document.getElementById(id);
  const clamp = (v,a,b) => Math.min(b, Math.max(a, v));
  const now = () => performance.now();

  const LZString=(function(){
    const keyStrBase64="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    const getBaseValue=(alphabet, character)=>alphabet.indexOf(character);
    const _compress=function(uncompressed, bitsPerChar, getCharFromInt){
      if(uncompressed==null) return ""; let i,value=0,context_dictionary={},context_dictionaryToCreate={},context_c="",context_wc="",context_w="",context_enlargeIn=2,context_dictSize=3,context_numBits=2,context_data=[],context_data_val=0,context_data_position=0;
      for(i=0;i<uncompressed.length;i+=1){ context_c=uncompressed.charAt(i); if(!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)){ context_dictionary[context_c]=context_dictSize++; context_dictionaryToCreate[context_c]=true; }
        context_wc=context_w+context_c; if(Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)){ context_w=context_wc; } else {
          if(Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)){
            let value=context_w.charCodeAt(0); for(let j=0;j<context_numBits;j++){ context_data_val=(context_data_val<<1); if(context_data_position==bitsPerChar-1){ context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; }
            for(let j=0;j<16;j++){ context_data_val=(context_data_val<<1)|((value>>j)&1); if(context_data_position==bitsPerChar-1){ context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; }
          } else { value=context_dictionary[context_w]; for(let j=0;j<context_numBits;j++){ context_data_val=(context_data_val<<1)| (value&1); if(context_data_position==bitsPerChar-1){ context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; value>>=1; }
          }
          context_enlargeIn--; if(context_enlargeIn==0){ context_enlargeIn=1<<context_numBits; context_numBits++; }
          context_dictionary[context_wc]=context_dictSize++; context_w=String(context_c);
        }
      }
      if(context_w!==''){
        if(Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)){
          let value=context_w.charCodeAt(0); for(let j=0;j<context_numBits;j++){ context_data_val=(context_data_val<<1); if(context_data_position==bitsPerChar-1){ context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; }
          for(let j=0;j<16;j++){ context_data_val=(context_data_val<<1)|((value>>j)&1); if(context_data_position==bitsPerChar-1){ context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; }
        } else { value=context_dictionary[context_w]; for(let j=0;j<context_numBits;j++){ context_data_val=(context_data_val<<1)| (value&1); if(context_data_position==bitsPerChar-1){ context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; value>>=1; }
        }
        context_enlargeIn--; if(context_enlargeIn==0){ context_enlargeIn=1<<context_numBits; context_numBits++; }
      }
      value=2; for(let j=0;j<context_numBits;j++){ context_data_val=(context_data_val<<1)| (value&1); if(context_data_position==bitsPerChar-1){ context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; }
      while(true){ context_data_val=(context_data_val<<1); if(context_data_position==bitsPerChar-1){ context_data.push(getCharFromInt(context_data_val)); break;} else context_data_position++; }
      return context_data.join('');
    };
    const _decompress=function(length, resetValue, getNextValue){ const dictionary=[], result=[], data={val:getNextValue(0),position=resetValue,index:1}; let enlargeIn=4, dictSize=4, numBits=3, entry, w, bits, resb, maxpower, power, c; function nextBits(n){ bits=0; maxpower=Math.pow(2,n); power=1; while(power!=maxpower){ resb=data.val & data.position; data.position >>=1; if(data.position==0){ data.position=resetValue; data.val=getNextValue(data.index++); } bits |= (resb>0?1:0)*power; power<<=1; } return bits; }
      for(let i=0;i<3;i++) dictionary[i]=i; bits=nextBits(2); switch(bits){case 0: c=String.fromCharCode(nextBits(16)); dictionary[3]=c; w=c; result.push(c); break; case 1: c=String.fromCharCode(nextBits(8)); dictionary[3]=c; w=c; result.push(c); break; case 2: return ""; }
      while(true){ if(data.index>length) return ""; bits=nextBits(numBits); let cc; switch(cc=bits){case 0: c=String.fromCharCode(nextBits(16)); dictionary[dictSize++]=c; enlargeIn--; if(enlargeIn==0){ enlargeIn=Math.pow(2,numBits); numBits++; } break; case 1: c=String.fromCharCode(nextBits(8)); dictionary[dictSize++]=c; enlargeIn--; if(enlargeIn==0){ enlargeIn=Math.pow(2,numBits); numBits++; } break; case 2: return result.join(''); default: }
        if(cc===0||cc===1) { w=c; result.push(c); continue; }
        let entryStr; if(bits<dictionary.length){ entryStr=dictionary[bits]; } else { if(bits===dictSize){ entryStr=w + w.charAt(0); } else { return ""; } }
        result.push(entryStr); dictionary[dictSize++]=w + entryStr.charAt(0); w=entryStr; enlargeIn--; if(enlargeIn==0){ enlargeIn=Math.pow(2,numBits); numBits++; }
      }
    };
    return {
      compressToBase64: function(input){ if(input==null) return ""; let res=_compress(input,6,function(a){return keyStrBase64.charAt(a)}); switch(res.length%4){default: case 0: return res; case 1: return res+"==="; case 2: return res+"=="; case 3: return res+"="; }
      },
      decompressFromBase64: function(input){ if(input==null) return ""; input=input.replace(/[^A-Za-z0-9\+\/\=]/g,""); return _decompress(input.length,32,function(index){ return getBaseValue(keyStrBase64,input.charAt(index)); }); }
    };
  })();
  const encodeForShare = (s) => 'z'+ LZString.compressToBase64(s);
  const decodeShared   = (s) => (s&&s[0]==='z') ? (LZString.decompressFromBase64(s.slice(1))||'') : s;

  const hostState = el('hostState');
  const peerState = el('peerState');
  const status = el('status');
  const latency = el('latency');
  const logEl = el('log');
  const meTag = el('meTag');
  const btnHostStart   = el('btnHostStart');
  const btnCopyOffer   = el('btnCopyOffer');
  const btnQrOffer     = el('btnQrOffer');
  const offerOut       = el('offerOut');
  const answerIn       = el('answerIn');
  const btnApplyAnswer = el('btnApplyAnswer');
  const btnScanAnswer  = el('btnScanAnswer');
  const btnPeerStart   = el('btnPeerStart');
  const offerIn        = el('offerIn');
  const btnApplyOffer  = el('btnApplyOffer');
  const btnScanOffer   = el('btnScanOffer');
  const answerOut      = el('answerOut');
  const btnCopyAnswer  = el('btnCopyAnswer');
  const btnQrAnswer    = el('btnQrAnswer');
  const qrModal  = el('qrModal');
  const qrCanvas = el('qrCanvas');
  const qrClose  = el('qrClose');
  const scanModal = el('scanModal');
  const scanVideo = el('scanVideo');
  const scanClose = el('scanClose');
  const chatInput = el('chatInput');
  const chatSend  = el('chatSend');
  const btnRunTests = el('btnRunTests');
  const btnStartGame = el('btnStartGame');
  const btnResetGame = el('btnResetGame');

     function log(msg){ const entry = `[${new Date().toLocaleTimeString()}] ${msg}\n`; logEl.textContent = entry + logEl.textContent; if (logEl.textContent.length > 8000) { logEl.textContent = logEl.textContent.slice(0, 8000); } }
  function setStatus(s, good){ status.textContent = s; status.className = 'small mono ' + (good ? 'ok' : 'muted'); }
  function setRoleTag(r){ meTag.textContent = r ? `${r} ready` : 'not joined'; }

  class Net {
    constructor(){ this.pc=null; this.dc=null; this.role=null; this.pingTimer=0; this.rtt=null; this.onopen=null; this.onclose=null; this.onmessage=null; }
    makePC(){ if (this.pc) { try { this.pc.close(); } catch(e){} this.pc = null; } if (this.dc) { try { this.dc.close(); } catch(e){} this.dc = null; } const rtcConfig = { iceServers: [] }; this.pc = new RTCPeerConnection(rtcConfig);
      this.pc.onconnectionstatechange = () => { const st=this.pc.connectionState; setStatus(`State: ${st}`, st === 'connected'); if(st==='failed') log('Connection failed, check network or HTTPS.'); };
      this.pc.onicecandidateerror = (e) => log('ICE error: ' + (e.errorText || e.hostCandidate || ''));
      return this.pc; }
    bindDC(channel){ this.dc = channel; chatSend.disabled = true;
      this.dc.onopen  = () => { setStatus('Connected', true); chatSend.disabled = false; this.startPings(); if(this.onopen) this.onopen(); };
      this.dc.onclose = () => { setStatus('Disconnected', false); chatSend.disabled = true; this.stopPings(); if(this.onclose) this.onclose(); btnHostStart.disabled=false; btnPeerStart.disabled=false; setRoleTag(null); hostState.textContent='idle'; peerState.textContent='idle'; };
      this.dc.onmessage = (e) => { try{ const msg = JSON.parse(e.data); if(msg.type==='ping'){ this.send({type:'pong', t:msg.t}); } else if(msg.type==='pong'){ this.rtt = Math.round(performance.now() - msg.t); latency.textContent = `RTT ~ ${this.rtt} ms`; } else { if(this.onmessage) this.onmessage(msg); } } catch (err) { log(`Raw: ${e.data}`); } };
    }
    startHost(){ this.role='host'; setRoleTag('host'); btnHostStart.disabled = true; btnPeerStart.disabled = true; hostState.textContent='creating';
      this.makePC(); const ch = this.pc.createDataChannel('game', { ordered:true }); this.bindDC(ch);
      return this.pc.createOffer().then(offer=>this.pc.setLocalDescription(offer)).then(()=>this.waitICE()).then(()=>{
        offerOut.value = JSON.stringify(this.pc.localDescription); btnCopyOffer.disabled = false; btnApplyAnswer.disabled = false; btnQrOffer.disabled = false; hostState.textContent='offer ready'; setStatus('Share offer with peer', false);
      });
    }
    startPeer(){ this.role='peer'; setRoleTag('peer'); btnPeerStart.disabled = true; btnHostStart.disabled = true; peerState.textContent='ready'; btnApplyOffer.disabled = false; }
    async applyOfferFromText(txt){ try{ if(this.role!=='peer'){ this.startPeer(); }
      this.makePC(); this.pc.ondatachannel = (e)=> this.bindDC(e.channel);
      const offer = JSON.parse(decodeShared(txt)); await this.pc.setRemoteDescription(offer);
      const answer = await this.pc.createAnswer(); await this.pc.setLocalDescription(answer); await this.waitICE();
      answerOut.value = JSON.stringify(this.pc.localDescription); btnCopyAnswer.disabled = false; btnQrAnswer.disabled = false; peerState.textContent ='answer ready'; setStatus('Send answer back to host', false);
    } catch(e){ log('Bad offer JSON'); } }
    async applyAnswerFromText(txt){ try{ const answer = JSON.parse(decodeShared(txt)); await this.pc.setRemoteDescription(answer); hostState.textContent='answer applied'; setStatus('Waiting for channel open', false); } catch(e){ log('Bad answer JSON'); } }
    send(obj){ if(this.dc && this.dc.readyState==='open'){ try{ this.dc.send(JSON.stringify(obj)); }catch(e){} } }
    startPings(){ this.stopPings(); this.pingTimer = setInterval(()=>{ this.send({type:'ping', t:performance.now()}); }, 1000); }
    stopPings(){ if(this.pingTimer){ clearInterval(this.pingTimer); this.pingTimer=0; } }
         async waitICE(){ if(!this.pc) return; if(this.pc.iceGatheringState==='complete') return; await new Promise((res)=>{ let done=false; const cleanup=()=>{ if(done) return; done=true; this.pc && this.pc.removeEventListener('icegatheringstatechange', check); res(); }; const check=()=>{ if(!this.pc) return cleanup(); if(this.pc.iceGatheringState==='complete'){ cleanup(); } }; this.pc.addEventListener('icegatheringstatechange', check); setTimeout(cleanup, 3000); }); }
  }

  const net = new Net();

  const canvas = el('game');
  const ctx = canvas.getContext('2d');
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let W = 960, H = 600; function resize(){ const rect = canvas.getBoundingClientRect(); W=Math.floor(rect.width*DPR); H=Math.floor(rect.height*DPR); canvas.width=W; canvas.height=H; } window.addEventListener('resize', resize); resize();

  const world = { w: 1600, h: 900 };
  const R = 22, SPEED = 360;
  const SCORE_TO_WIN = 10, ROUND_TIME = 120;
  const TAG_COOLDOWN = 800;

  const me   = { x: 200, y: 200, color: '#2bd27e', score:0, name:'you' };
  const them = { x: 600, y: 200, color: '#ff6262', score:0, name:'peer', tx:600, ty:200, lastUpdate:0 };

  let role = null;
  let game = { started:false, it:'me', tLeft: ROUND_TIME, lastTick: now(), lastTagAt: 0 };

  const keys = new Set();
  window.addEventListener('keydown', e => { if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'].includes(e.key)) { keys.add(e.key.toLowerCase()); e.preventDefault(); } });
  window.addEventListener('keyup', e => { keys.delete(e.key.toLowerCase()); });

  function moveLocal(dt){ let dx=0, dy=0; if(keys.has('arrowup')||keys.has('w')) dy-=1; if(keys.has('arrowdown')||keys.has('s')) dy+=1; if(keys.has('arrowleft')||keys.has('a')) dx-=1; if(keys.has('arrowright')||keys.has('d')) dx+=1; if(dx||dy){ const m=Math.hypot(dx,dy)||1; me.x=clamp(me.x+dx/m*SPEED*dt, R, world.w-R); me.y=clamp(me.y+dy/m*SPEED*dt, R, world.h-R); sendThrottled({ type:'pos', x:me.x, y:me.y }); } }

  function updateRemote(dt){ const lerp = (a,b,t)=>a+(b-a)*t; const LERP_SPD = 10; them.x = lerp(them.x, them.tx, Math.min(1, LERP_SPD*dt)); them.y = lerp(them.y, them.ty, Math.min(1, LERP_SPD*dt)); }

  function hostTick(dt){ if(!game.started) return; game.tLeft = Math.max(0, game.tLeft - dt); if(game.tLeft===0) endRound();
    const canTag = (now() - game.lastTagAt) > TAG_COOLDOWN;
    if(canTag){ const dx = me.x - them.x, dy = me.y - them.y; const touching = Math.hypot(dx,dy) <= R*2; if(touching){ if(game.it==='me'){ me.score++; game.it='peer'; game.lastTagAt = now(); broadcastState(); checkWin(); } else if(game.it==='peer'){ them.score++; game.it='me'; game.lastTagAt = now(); broadcastState(); checkWin(); } } }
    snapshotTimer -= dt; if(snapshotTimer<=0){ snapshotTimer = 0.2; broadcastState(); }
  }

  function checkWin(){ if(me.score>=SCORE_TO_WIN || them.score>=SCORE_TO_WIN){ endRound(); } }

  function endRound(){ game.started=false; broadcastState(); }

  function draw(){ const cx=(me.x+them.x)/2, cy=(me.y+them.y)/2; const scale = Math.min(W/world.w, H/world.h); const vw=W/scale, vh=H/scale; const camX=clamp(cx - vw/2, 0, Math.max(0, world.w - vw)); const camY=clamp(cy - vh/2, 0, Math.max(0, world.h - vh)); ctx.save(); ctx.scale(scale, scale); ctx.clearRect(0,0,vw,vh); ctx.fillStyle='#0b0e1a'; ctx.fillRect(0,0,vw,vh);
    ctx.strokeStyle='#1e2447'; ctx.lineWidth=1; for(let x=0;x<world.w;x+=80){ line(x - camX, 0 - camY, x - camX, world.h - camY); } for(let y=0;y<world.h;y+=80){ line(0 - camX, y - camY, world.w - camX, y - camY); }
    drawPlayer(me, camX, camY, game.it==='me');
    drawPlayer(them, camX, camY, game.it==='peer');
    ctx.fillStyle='#e8ecff'; ctx.font='16px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial'; ctx.textAlign='left';
    const tText = `Time ${Math.ceil(game.tLeft)}s`; ctx.fillText(tText, 12 - camX, 24 - camY);
    ctx.fillText(`You ${me.score}`, 12 - camX, 46 - camY);
    ctx.fillText(`Peer ${them.score}`, 12 - camX, 68 - camY);
    ctx.textAlign='center'; ctx.font='18px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    const roleText = game.started ? (game.it==='me' ? 'You are IT' : 'You are running') : 'Press Start';
    ctx.fillText(roleText, (vw/2), 28 - camY);
    ctx.restore(); }

  function line(x1,y1,x2,y2){ ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); }
  function drawPlayer(p, camX, camY, isIT){ ctx.beginPath(); ctx.arc(p.x - camX, p.y - camY, R, 0, Math.PI*2); ctx.fillStyle = p.color; ctx.fill(); if(isIT){ ctx.strokeStyle='#ffd24e'; ctx.lineWidth=3; ctx.stroke(); } }

  let lastTS = now(); let snapshotTimer = 0.2;
  function loop(ts){ const dt = Math.min(0.05, (ts - lastTS)/1000); lastTS = ts; moveLocal(dt); updateRemote(dt); if(role==='host') hostTick(dt); draw(); requestAnimationFrame(loop); }
  requestAnimationFrame(loop);

  net.onopen = () => { btnStartGame.disabled = (net.role!=='host'); btnResetGame.disabled = (net.role!=='host'); if(net.role==='host'){
      me.x=200; me.y=200; them.x=1400; them.y=700; them.tx=them.x; them.ty=them.y; me.score=0; them.score=0; game={ started:false, it: Math.random()<0.5? 'me':'peer', tLeft: ROUND_TIME, lastTick: now(), lastTagAt: 0 }; broadcastState(); }
  };
  net.onclose = () => { btnStartGame.disabled = true; btnResetGame.disabled = true; chatSend.disabled = true; };
  net.onmessage = (msg) => { if(msg.type==='pos'){ them.tx = clamp(msg.x, R, world.w-R); them.ty = clamp(msg.y, R, world.h-R); them.lastUpdate = now(); }
    else if(msg.type==='state'){ applyState(msg.state); }
    else if(msg.type==='chat'){ log(`Peer: ${msg.text}`); }
  };

  function broadcastState(){ if(net.role==='host'){ const state = { me:{x:me.x,y:me.y,score:me.score}, them:{x:them.x,y:them.y,score:them.score}, started:game.started, it:game.it, tLeft:Math.ceil(game.tLeft) }; net.send({ type:'state', state: state }); } }
  function applyState(s){
    if(net.role==='peer'){
      me.x = s.them.x; me.y = s.them.y; me.score = s.them.score;
      them.tx = s.me.x; them.ty = s.me.y; them.score = s.me.score;
      game.started = s.started; game.it = (s.it==='me') ? 'peer' : 'me'; game.tLeft = s.tLeft; }
    else {
      me.x = s.me.x; me.y = s.me.y; me.score = s.me.score; them.tx = s.them.x; them.ty = s.them.y; them.score = s.them.score; game.started = s.started; game.it = s.it; game.tLeft = s.tLeft; }
  }

  let lastSend = 0; function sendThrottled(obj){ const t=now(); if(t - lastSend > 33){ net.send(obj); lastSend = t; } }

  btnHostStart.onclick = async () => { try { role='host'; net.role='host'; await net.startHost(); } catch (e) { log('Host failed: ' + (e && e.message ? e.message : e)); btnHostStart.disabled=false; btnPeerStart.disabled=false; setRoleTag(null); hostState.textContent='idle'; } };
  btnPeerStart.onclick = () => { try { role='peer'; net.startPeer(); } catch (e) { log('Peer init failed: ' + (e && e.message ? e.message : e)); btnHostStart.disabled=false; btnPeerStart.disabled=false; setRoleTag(null); peerState.textContent='idle'; } };
  btnCopyOffer.onclick = async () => { await navigator.clipboard.writeText(encodeForShare(offerOut.value)); btnCopyOffer.textContent='Copied'; setTimeout(()=>btnCopyOffer.textContent='Copy', 800); };
  btnCopyAnswer.onclick = async () => { await navigator.clipboard.writeText(encodeForShare(answerOut.value)); btnCopyAnswer.textContent='Copied'; setTimeout(()=>btnCopyAnswer.textContent='Copy', 800); };

  async function applyAnswerFromText(txt){ await net.applyAnswerFromText(txt); }
  async function applyOfferFromText(txt){ await net.applyOfferFromText(txt); }
  btnApplyAnswer.onclick = async ()=>{ await applyAnswerFromText(answerIn.value); };
  btnApplyOffer.onclick  = async ()=>{ await applyOfferFromText(offerIn.value); };

  btnStartGame.onclick = () => { if(net.role!=='host') return; game.started=true; game.tLeft = ROUND_TIME; game.lastTagAt = 0; broadcastState(); };
  btnResetGame.onclick = () => { if(net.role!=='host') return; me.x=200; me.y=200; them.x=1400; them.y=700; them.tx=them.x; them.ty=them.y; me.score=0; them.score=0; game.started=false; game.it = Math.random()<0.5 ? 'me' : 'peer'; game.tLeft = ROUND_TIME; broadcastState(); };

  chatSend.onclick = () => { const text = chatInput.value.trim(); if(!text) return; net.send({ type:'chat', text: text }); log('You: ' + text); chatInput.value=''; };
  chatInput.addEventListener('keydown', e => { if (e.key === 'Enter') chatSend.click(); });

  function drawQrToCanvas(text, canvas, scale){ 
    try {
      // Firefox compatibility: ensure text is valid
      if (!text || typeof text !== 'string') {
        text = 'QR Code Error';
      }
      
      var qr = qrcode(1, 'L'); // Use type 1 instead of 0
      
      qr.addData(text); 
      qr.make(); 
      
      var count = qr.getModuleCount(); 
      
      var size = count * scale; 
      canvas.width = canvas.height = Math.max(240, size); 
      var ctx2 = canvas.getContext('2d'); 
      
      // Firefox compatibility: ensure canvas context is valid
      if (!ctx2) {
        throw new Error('Canvas 2D context not available');
      }
      
      ctx2.fillStyle = '#fff'; 
      ctx2.fillRect(0,0,canvas.width,canvas.height); 
      var offset = Math.floor((canvas.width - size)/2); 
      
      for(var r=0;r<count;r++){ 
        for(var c=0;c<count;c++){ 
          ctx2.fillStyle = qr.isDark(r,c)? '#000':'#fff'; 
          ctx2.fillRect(offset + c*scale, offset + r*scale, scale, scale); 
        } 
      }
    } catch(e) {
      console.error('QR generation error:', e);
      // Fallback to simple pattern if QR generation fails
      canvas.width = canvas.height = 240;
      var ctx2 = canvas.getContext('2d');
      if (ctx2) {
        ctx2.fillStyle = '#fff';
        ctx2.fillRect(0,0,canvas.width,canvas.height);
        // Draw a simple pattern to indicate error
        for(var r=0;r<8;r++){ 
          for(var c=0;c<8;c++){ 
            ctx2.fillStyle = (r + c) % 2 === 0 ? '#000':'#fff'; 
            ctx2.fillRect(r*30, c*30, 30, 30); 
          } 
        }
      }
    }
  }
  function showQR(text){ try{ drawQrToCanvas(encodeForShare(text), qrCanvas, 8); qrModal.classList.add('show'); } catch(e){ log('QR error: ' + e.message); } }
  btnQrOffer.onclick  = () => { if(!offerOut.value) return; showQR(offerOut.value); };
  btnQrAnswer.onclick = () => { if(!answerOut.value) return; showQR(answerOut.value); };
  qrClose.onclick     = () => { qrModal.classList.remove('show'); };

  let scanStream=null; let scanRunning=false; let detector=null;
  async function startScan(targetField){ try{
      if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
        alert('Camera requires HTTPS or localhost. Use copy paste if not available.'); return; }
      if (!('BarcodeDetector' in window)) { log('QR scan unsupported in this browser'); alert('QR scanning not supported here. Use copy paste instead.'); return; }
      detector = new BarcodeDetector({ formats:['qr_code'] }); scanModal.classList.add('show');
      scanStream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'environment' }, audio:false }); scanVideo.srcObject = scanStream; await scanVideo.play(); scanRunning=true;
      const loop = async ()=>{ if(!scanRunning) return; try{ const codes = await detector.detect(scanVideo); if(codes && codes.length){ const raw = codes[0].rawValue || ''; if(raw){ targetField.value = raw; stopScan(); if (targetField === offerIn) { await applyOfferFromText(raw); } else if (targetField === answerIn) { await applyAnswerFromText(raw); } return; } } } catch (err) {} requestAnimationFrame(loop); };
      requestAnimationFrame(loop);
    }catch(e){ log('Camera error: ' + e.message); alert('Camera access failed. Check permissions.'); stopScan(); }
  }
  function stopScan(){ scanRunning=false; if(scanStream){ scanStream.getTracks().forEach(t=>t.stop()); scanStream=null; } scanModal.classList.remove('show'); }
  btnScanOffer.onclick  = () => startScan(offerIn);
  btnScanAnswer.onclick = () => startScan(answerIn);
  scanClose.onclick     = () => stopScan();

  btnRunTests.onclick = () => {
    const results = []; const ok=(name,cond)=>results.push(`${cond? 'âœ…':'âŒ'} ${name}`);
    try { const q = qrcode(1, 'L'); q.addData('test'); q.make(); ok('QR encode short text', q.getModuleCount() > 0); } catch(e){ ok('QR encode short text', false); log('QR test error: '+e.message); }
    try { const tmp = document.createElement('canvas'); drawQrToCanvas(encodeForShare('hello'), tmp, 4); ok('drawQrToCanvas runs', tmp.width > 0); } catch(e){ ok('drawQrToCanvas runs', false); log('drawQrToCanvas error: '+e.message); }
    ok('RTCPeerConnection present', !!window.RTCPeerConnection);
    ok('BarcodeDetector present (optional)', 'BarcodeDetector' in window);
    ok('#btnQrOffer single element', document.querySelectorAll('#btnQrOffer').length === 1);
    ok('#btnQrAnswer single element', document.querySelectorAll('#btnQrAnswer').length === 1);
    try { const s='{"a":1}'; const enc=encodeForShare(s); const dec=decodeShared(enc); ok('Compression roundtrip', dec===s && enc.startsWith('z')); } catch(e){ ok('Compression roundtrip', false); }
    try { const s2='{"b":2}'; ok('decodeShared raw passthrough', decodeShared(s2)===s2); } catch(e){ ok('decodeShared raw passthrough', false); }
    try { ok('RS table present', typeof RS_BLOCK_TABLE==='object' && !!RS_BLOCK_TABLE[(QRErrorCorrectLevel.L<<8)+40]); } catch(e){ ok('RS table present', false); }
    try { const big = JSON.stringify({ s: 'x'.repeat(2000) }); const enc=encodeForShare(big); const dec=decodeShared(enc); ok('Large compression roundtrip', dec===big); ok('Large compression shrinks', enc.length < big.length); } catch(e){ ok('Large compression roundtrip', false); }
    try { const s3=''; const enc3=encodeForShare(s3); const dec3=decodeShared(enc3); ok('Empty string roundtrip', dec3===s3 && enc3.startsWith('z')); } catch(e){ ok('Empty string roundtrip', false); }
    try { const st={ started:false, it:'me', tLeft:60, lastTick:0, lastTagAt:0 }; ok('Game state shape', typeof st.it==='string' && typeof st.tLeft==='number'); } catch(e){ ok('Game state shape', false); }
    try { const snap={ me:{x:1,y:2,score:0}, them:{x:3,y:4,score:0}, started:true, it:'me', tLeft:100 }; ok('State snapshot object', !!snap.me && !!snap.them && typeof snap.started==='boolean'); } catch(e){ ok('State snapshot object', false); }
    ok('Secure origin for camera', location.protocol==='https:' || location.hostname==='localhost' || location.hostname==='127.0.0.1');
    try { const t='{"t":"Ã©ðŸ˜Š"}'; const enc=encodeForShare(t); const dec=decodeShared(enc); ok('Unicode roundtrip', dec===t); } catch(e){ ok('Unicode roundtrip', false); }
    try { const enc=encodeForShare('{"k":1}'); ok('Share prefix', enc[0]==='z'); ok('Base64 charset', /^[A-Za-z0-9+/=]+$/.test(enc.slice(1))); } catch(e){ ok('Base64 charset', false); }
    try { const state={ me:{x:1,y:2,score:0}, them:{x:3,y:4,score:0}, started:false, it:'me', tLeft:10 }; const copy=JSON.parse(JSON.stringify(state)); ok('State JSON roundtrip', copy.me.x===1 && copy.it==='me'); } catch(e){ ok('State JSON roundtrip', false); }
    try { const obj = { type:'x', state:{ n:1 } }; const s = JSON.stringify(obj); ok('Object literal serializes', /\{"type":"x","state":\{"n":1\}\}/.test(s)); } catch(e){ ok('Object literal serializes', false); }
    log(results.join('\n'));
  };
})();
</script>
</body>
</html>
