<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#0a0e27">
  <title>Smash Impact - Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      user-select: none;
    }

    :root {
      --primary: #6366f1;
      --secondary: #22d3ee;
      --success: #10b981;
      --danger: #ef4444;
      --warning: #f59e0b;
      --bg-dark: #0a0e27;
      --surface: rgba(26, 31, 58, 0.9);
      --text: #e2e8f0;
      --text-muted: #94a3b8;
      --joystick-size: 120px;
      --joystick-knob: 50px;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-dark);
      color: var(--text);
      overflow: hidden;
      position: fixed;
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    /* Game container */
    .game-container {
      width: 100%;
      height: 100%;
      position: relative;
      display: flex;
      flex-direction: column;
    }

    /* Top HUD */
    .hud-top {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(to bottom, rgba(10, 14, 39, 0.9), transparent);
      padding: env(safe-area-inset-top) 20px 20px;
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .score-display {
      display: flex;
      gap: 20px;
      align-items: center;
    }

    .score-item {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .score-label {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .score-value {
      font-size: 24px;
      font-weight: bold;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .timer {
      background: var(--surface);
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
      backdrop-filter: blur(10px);
    }

    .connection-indicator {
      display: flex;
      align-items: center;
      gap: 6px;
      background: var(--surface);
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 12px;
      backdrop-filter: blur(10px);
    }

    .connection-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--success);
      animation: pulse 2s infinite;
    }

    .connection-dot.disconnected {
      background: var(--danger);
      animation: blink 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.2); }
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    /* Game canvas */
    #gameCanvas {
      flex: 1;
      width: 100%;
      background: radial-gradient(circle at center, #1a1f3a, #0a0e27);
      touch-action: none;
    }

    /* Mobile controls */
    .mobile-controls {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 20px;
      padding-bottom: calc(20px + env(safe-area-inset-bottom));
      pointer-events: none;
      z-index: 200;
    }

    .controls-container {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      max-width: 600px;
      margin: 0 auto;
      width: 100%;
    }

    /* Joystick */
    .joystick-wrapper {
      pointer-events: auto;
      position: relative;
    }

    .joystick {
      width: var(--joystick-size);
      height: var(--joystick-size);
      background: radial-gradient(circle, rgba(99, 102, 241, 0.1), rgba(99, 102, 241, 0.05));
      border: 2px solid rgba(99, 102, 241, 0.3);
      border-radius: 50%;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(10px);
      transition: border-color 0.3s ease;
    }

    .joystick.active {
      border-color: rgba(99, 102, 241, 0.6);
      background: radial-gradient(circle, rgba(99, 102, 241, 0.2), rgba(99, 102, 241, 0.1));
    }

    .joystick-knob {
      width: var(--joystick-knob);
      height: var(--joystick-knob);
      background: linear-gradient(135deg, var(--primary), var(--primary) 50%, var(--secondary));
      border-radius: 50%;
      position: absolute;
      box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
      transition: transform 0.1s ease-out;
      pointer-events: none;
    }

    /* Direction indicators */
    .joystick::before {
      content: '';
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      border-bottom: 6px solid rgba(255, 255, 255, 0.2);
    }

    .joystick::after {
      content: '';
      position: absolute;
      inset: 20px;
      border: 1px dashed rgba(255, 255, 255, 0.1);
      border-radius: 50%;
    }

    /* Action buttons */
    .action-buttons {
      pointer-events: auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
    }

    .action-btn {
      width: 60px;
      height: 60px;
      background: radial-gradient(circle, rgba(34, 211, 238, 0.2), rgba(34, 211, 238, 0.1));
      border: 2px solid rgba(34, 211, 238, 0.4);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      backdrop-filter: blur(10px);
      transition: all 0.2s ease;
      position: relative;
    }

    .action-btn:active {
      transform: scale(0.95);
      background: radial-gradient(circle, rgba(34, 211, 238, 0.4), rgba(34, 211, 238, 0.2));
      border-color: rgba(34, 211, 238, 0.8);
    }

    .action-btn.primary {
      width: 70px;
      height: 70px;
      font-size: 28px;
    }

    .action-btn-label {
      position: absolute;
      bottom: -18px;
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* Desktop controls (hidden on mobile) */
    .desktop-controls {
      display: none;
    }

    /* Pause menu */
    .pause-menu {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      backdrop-filter: blur(10px);
    }

    .pause-menu.active {
      display: flex;
    }

    .pause-content {
      background: var(--surface);
      border-radius: 20px;
      padding: 30px;
      text-align: center;
      max-width: 300px;
      width: 90%;
    }

    .pause-title {
      font-size: 24px;
      margin-bottom: 20px;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .pause-buttons {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .pause-btn {
      padding: 12px 24px;
      background: linear-gradient(135deg, var(--primary), var(--primary));
      border: none;
      border-radius: 10px;
      color: white;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .pause-btn:active {
      transform: scale(0.95);
    }

    .pause-btn.secondary {
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    /* Menu button */
    .menu-btn {
      position: absolute;
      top: env(safe-area-inset-top);
      right: 20px;
      width: 40px;
      height: 40px;
      background: var(--surface);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      z-index: 101;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* Responsive adjustments */
    @media (min-width: 768px) {
      :root {
        --joystick-size: 150px;
        --joystick-knob: 60px;
      }

      .action-btn {
        width: 70px;
        height: 70px;
      }

      .action-btn.primary {
        width: 80px;
        height: 80px;
      }

      .mobile-controls {
        display: none;
      }

      .desktop-controls {
        display: block;
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--surface);
        padding: 10px 20px;
        border-radius: 10px;
        font-size: 12px;
        color: var(--text-muted);
        backdrop-filter: blur(10px);
      }
    }

    /* Landscape mode adjustments */
    @media (orientation: landscape) and (max-height: 500px) {
      .hud-top {
        padding-top: 10px;
        padding-bottom: 10px;
      }

      .score-value {
        font-size: 20px;
      }

      :root {
        --joystick-size: 100px;
        --joystick-knob: 40px;
      }

      .action-btn {
        width: 50px;
        height: 50px;
        font-size: 20px;
      }

      .action-btn.primary {
        width: 60px;
        height: 60px;
        font-size: 24px;
      }
    }

    /* Performance optimizations */
    .joystick-knob,
    .action-btn {
      will-change: transform;
    }

    /* Debug info */
    .debug-info {
      position: absolute;
      top: 100px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 10px;
      display: none;
      z-index: 500;
    }

    .debug-info.active {
      display: block;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <!-- Top HUD -->
    <div class="hud-top">
      <div class="score-display">
        <div class="score-item">
          <span class="score-label">You</span>
          <span class="score-value" id="scoreYou">0</span>
        </div>
        <div class="score-item">
          <span class="score-label">Them</span>
          <span class="score-value" id="scoreThem">0</span>
        </div>
      </div>
      
      <div class="timer" id="gameTimer">00:00</div>
      
      <div class="connection-indicator">
        <span class="connection-dot" id="connectionDot"></span>
        <span id="connectionText">Connected</span>
      </div>
    </div>

    <!-- Menu button -->
    <button class="menu-btn" onclick="togglePause()">☰</button>

    <!-- Game canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- Mobile controls -->
    <div class="mobile-controls" id="mobileControls">
      <div class="controls-container">
        <!-- Joystick -->
        <div class="joystick-wrapper">
          <div class="joystick" id="joystick">
            <div class="joystick-knob" id="joystickKnob"></div>
          </div>
        </div>

        <!-- Action buttons -->
        <div class="action-buttons">
          <button class="action-btn" id="btnBoost" data-action="boost">
            <span>⚡</span>
            <span class="action-btn-label">Boost</span>
          </button>
          <button class="action-btn primary" id="btnAttack" data-action="attack">
            <span>💥</span>
            <span class="action-btn-label">Attack</span>
          </button>
        </div>
      </div>
    </div>

    <!-- Desktop controls hint -->
    <div class="desktop-controls">
      Use WASD or Arrow Keys to move • Space to attack • Shift to boost
    </div>

    <!-- Pause menu -->
    <div class="pause-menu" id="pauseMenu">
      <div class="pause-content">
        <h2 class="pause-title">Game Paused</h2>
        <div class="pause-buttons">
          <button class="pause-btn" onclick="resumeGame()">Resume</button>
          <button class="pause-btn secondary" onclick="toggleDebug()">Toggle Debug</button>
          <button class="pause-btn secondary" onclick="exitGame()">Exit to Menu</button>
        </div>
      </div>
    </div>

    <!-- Debug info -->
    <div class="debug-info" id="debugInfo">
      <div>FPS: <span id="fps">0</span></div>
      <div>Joystick: <span id="joystickDebug">0, 0</span></div>
      <div>Touch: <span id="touchDebug">none</span></div>
      <div>Device: <span id="deviceDebug">-</span></div>
    </div>
  </div>

  <!-- Multiplayer synchronization -->
  <script src="multiplayer.js"></script>
  
  <script type="module">
    // Mobile joystick controller
    class JoystickController {
      constructor(element, knob) {
        this.element = element;
        this.knob = knob;
        this.active = false;
        this.startPos = { x: 0, y: 0 };
        this.currentPos = { x: 0, y: 0 };
        this.vector = { x: 0, y: 0 };
        
        // Calculate radius after a small delay to ensure elements are rendered
        this.radius = 60; // Default value
        this.knobRadius = 20; // Default value
        this.maxDistance = 40; // Default value
        
        // Store bound event handlers for cleanup
        this.boundHandleStart = this.handleStart.bind(this);
        this.boundHandleMove = this.handleMove.bind(this);
        this.boundHandleEnd = this.handleEnd.bind(this);
        this.boundHandleMouseStart = this.handleMouseStart.bind(this);
        this.boundHandleMouseMove = this.handleMouseMove.bind(this);
        this.boundHandleMouseEnd = this.handleMouseEnd.bind(this);
        
        // Recalculate once element is ready
        requestAnimationFrame(() => {
          if (element && element.offsetWidth) {
            this.radius = element.offsetWidth / 2;
            this.knobRadius = knob ? knob.offsetWidth / 2 : 20;
            this.maxDistance = this.radius - this.knobRadius;
          }
        });
        
        this.init();
      }

      init() {
        // Touch events
        this.element.addEventListener('touchstart', this.boundHandleStart, { passive: false });
        this.element.addEventListener('touchmove', this.boundHandleMove, { passive: false });
        this.element.addEventListener('touchend', this.boundHandleEnd, { passive: false });
        this.element.addEventListener('touchcancel', this.boundHandleEnd, { passive: false });
        
        // Mouse events for testing
        this.element.addEventListener('mousedown', this.boundHandleMouseStart);
        document.addEventListener('mousemove', this.boundHandleMouseMove);
        document.addEventListener('mouseup', this.boundHandleMouseEnd);
      }
      
      destroy() {
        // Remove all event listeners
        this.element.removeEventListener('touchstart', this.boundHandleStart);
        this.element.removeEventListener('touchmove', this.boundHandleMove);
        this.element.removeEventListener('touchend', this.boundHandleEnd);
        this.element.removeEventListener('touchcancel', this.boundHandleEnd);
        this.element.removeEventListener('mousedown', this.boundHandleMouseStart);
        document.removeEventListener('mousemove', this.boundHandleMouseMove);
        document.removeEventListener('mouseup', this.boundHandleMouseEnd);
      }

      handleStart(e) {
        e.preventDefault();
        this.active = true;
        this.element.classList.add('active');
        
        const touch = e.touches[0];
        const rect = this.element.getBoundingClientRect();
        this.startPos = {
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2
        };
        
        this.updatePosition(touch.clientX, touch.clientY);
      }

      handleMove(e) {
        if (!this.active) return;
        e.preventDefault();
        
        const touch = e.touches[0];
        this.updatePosition(touch.clientX, touch.clientY);
      }

      handleEnd(e) {
        e.preventDefault();
        this.active = false;
        this.element.classList.remove('active');
        this.resetPosition();
      }

      handleMouseStart(e) {
        if ('ontouchstart' in window) return; // Ignore mouse on touch devices
        this.active = true;
        this.element.classList.add('active');
        
        const rect = this.element.getBoundingClientRect();
        this.startPos = {
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2
        };
        
        this.updatePosition(e.clientX, e.clientY);
      }

      handleMouseMove(e) {
        if (!this.active || 'ontouchstart' in window) return;
        this.updatePosition(e.clientX, e.clientY);
      }

      handleMouseEnd(e) {
        if ('ontouchstart' in window) return;
        this.active = false;
        this.element.classList.remove('active');
        this.resetPosition();
      }

      updatePosition(x, y) {
        const deltaX = x - this.startPos.x;
        const deltaY = y - this.startPos.y;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        if (distance <= this.maxDistance) {
          this.currentPos = { x: deltaX, y: deltaY };
        } else {
          const angle = Math.atan2(deltaY, deltaX);
          this.currentPos = {
            x: Math.cos(angle) * this.maxDistance,
            y: Math.sin(angle) * this.maxDistance
          };
        }
        
        // Update knob position
        this.knob.style.transform = `translate(${this.currentPos.x}px, ${this.currentPos.y}px)`;
        
        // Calculate normalized vector (-1 to 1)
        this.vector = {
          x: this.currentPos.x / this.maxDistance,
          y: this.currentPos.y / this.maxDistance
        };
        
        // Update debug info
        if (window.debugMode) {
          document.getElementById('joystickDebug').textContent = 
            `${this.vector.x.toFixed(2)}, ${this.vector.y.toFixed(2)}`;
        }
      }

      resetPosition() {
        this.currentPos = { x: 0, y: 0 };
        this.vector = { x: 0, y: 0 };
        this.knob.style.transform = 'translate(0, 0)';
        
        if (window.debugMode) {
          document.getElementById('joystickDebug').textContent = '0, 0';
        }
      }

      getVector() {
        return this.vector;
      }
    }

    // Action button handler
    class ActionButton {
      constructor(element, action) {
        this.element = element;
        this.action = action;
        this.pressed = false;
        
        // Store bound handlers
        this.boundHandlePress = this.handlePress.bind(this);
        this.boundHandleRelease = this.handleRelease.bind(this);
        
        this.init();
      }

      init() {
        // Touch events
        this.element.addEventListener('touchstart', this.boundHandlePress, { passive: false });
        this.element.addEventListener('touchend', this.boundHandleRelease, { passive: false });
        this.element.addEventListener('touchcancel', this.boundHandleRelease, { passive: false });
        
        // Mouse events
        this.element.addEventListener('mousedown', this.boundHandlePress);
        this.element.addEventListener('mouseup', this.boundHandleRelease);
        this.element.addEventListener('mouseleave', this.boundHandleRelease);
      }
      
      destroy() {
        // Remove all event listeners
        this.element.removeEventListener('touchstart', this.boundHandlePress);
        this.element.removeEventListener('touchend', this.boundHandleRelease);
        this.element.removeEventListener('touchcancel', this.boundHandleRelease);
        this.element.removeEventListener('mousedown', this.boundHandlePress);
        this.element.removeEventListener('mouseup', this.boundHandleRelease);
        this.element.removeEventListener('mouseleave', this.boundHandleRelease);
      }

      handlePress(e) {
        e.preventDefault();
        this.pressed = true;
        this.element.classList.add('pressed');
        
        // Trigger action
        if (window.gameInstance) {
          window.gameInstance.handleAction(this.action, true);
        }
        
        // Haptic feedback on mobile
        if ('vibrate' in navigator) {
          navigator.vibrate(10);
        }
      }

      handleRelease(e) {
        e.preventDefault();
        this.pressed = false;
        this.element.classList.remove('pressed');
        
        // Stop action
        if (window.gameInstance) {
          window.gameInstance.handleAction(this.action, false);
        }
      }

      isPressed() {
        return this.pressed;
      }
    }

    // Game class
    class MobileGame {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.running = false;
        this.paused = false;
        
        // Check for multiplayer
        this.isMultiplayer = sessionStorage.getItem('p2pConnected') === 'true';
        this.multiplayer = null;
        
        if (this.isMultiplayer) {
          // Initialize multiplayer synchronization
          this.multiplayer = new window.MultiplayerGame();
          this.setupMultiplayer();
        }
        
        // Game state (will be overridden by multiplayer if connected)
        this.player = {
          x: 0,
          y: 0,
          vx: 0,
          vy: 0,
          radius: 20,
          color: '#6366f1',
          speed: 5,
          boosting: false
        };
        
        this.enemy = {
          x: 0,
          y: 0,
          radius: 20,
          color: '#ef4444'
        };
        
        this.score = { you: 0, them: 0 };
        this.startTime = Date.now();
        
        // Controls
        this.joystick = null;
        this.buttons = {};
        
        // Animation
        this.lastTime = 0;
        this.fps = 0;
        this.frameCount = 0;
        this.fpsTime = 0;
        
        // Store cleanup references
        this.animationId = null;
        this.connectionCheckInterval = null;
        this.connectionCheckTimeout = null;
        this.resizeHandler = () => this.resizeCanvas();
        this.orientationHandler = () => {
          setTimeout(() => this.resizeCanvas(), 100);
        };
        
        this.init();
      }

      setupMultiplayer() {
        // Set up callbacks
        this.multiplayer.onAttack = () => {
          // Visual feedback for attack
          this.showAttackEffect();
        };
        
        this.multiplayer.onHit = () => {
          // Visual feedback for being hit
          if ('vibrate' in navigator) {
            navigator.vibrate([50, 20, 50]);
          }
        };
        
        this.multiplayer.onScoreChange = () => {
          // Update score display
          this.updateScoreDisplay();
        };
        
        // The multiplayer instance will handle connection setup via BroadcastChannel
        // No need to manually pass connection here anymore
        console.log('Multiplayer game initialized, waiting for connection...');
        
        // Update UI to show connection status
        const connectionDot = document.getElementById('connectionDot');
        const connectionText = document.getElementById('connectionText');
        
        // Check connection status periodically
        this.connectionCheckInterval = setInterval(() => {
          if (this.multiplayer && this.multiplayer.dataChannel) {
            connectionDot.style.background = '#10b981';
            connectionText.textContent = 'Connected';
            clearInterval(this.connectionCheckInterval);
            this.connectionCheckInterval = null;
          } else {
            connectionDot.style.background = '#f59e0b';
            connectionText.textContent = 'Connecting...';
          }
        }, 500);
        
        // Timeout after 5 seconds
        this.connectionCheckTimeout = setTimeout(() => {
          if (!this.multiplayer.dataChannel) {
            connectionDot.style.background = '#ef4444';
            connectionText.textContent = 'Connection Failed';
            if (this.connectionCheckInterval) {
              clearInterval(this.connectionCheckInterval);
              this.connectionCheckInterval = null;
            }
          }
          this.connectionCheckTimeout = null;
        }, 5000);
      }

      showAttackEffect() {
        // Visual attack effect (will be rendered in next frame)
        this.attackEffect = {
          x: this.player.x,
          y: this.player.y,
          radius: 50,
          alpha: 1
        };
      }

      updateScoreDisplay() {
        if (this.multiplayer) {
          const state = this.multiplayer.getGameState();
          const myRole = this.multiplayer.role;
          
          if (myRole === 'host') {
            document.getElementById('scoreYou').textContent = state.players.host.score;
            document.getElementById('scoreThem').textContent = state.players.player.score;
          } else {
            document.getElementById('scoreYou').textContent = state.players.player.score;
            document.getElementById('scoreThem').textContent = state.players.host.score;
          }
        }
      }

      init() {
        // Setup canvas
        this.resizeCanvas();
        window.addEventListener('resize', this.resizeHandler);
        window.addEventListener('orientationchange', this.orientationHandler);
        
        // Initialize controls
        const deviceType = sessionStorage.getItem('deviceType') || 'mobile';
        if (deviceType === 'mobile' || 'ontouchstart' in window) {
          this.initMobileControls();
        } else {
          this.initDesktopControls();
        }
        
        // Start game
        this.reset();
        this.start();
      }
      
      destroy() {
        // Stop animation loop
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
          this.animationId = null;
        }
        
        // Clear intervals and timeouts
        if (this.connectionCheckInterval) {
          clearInterval(this.connectionCheckInterval);
          this.connectionCheckInterval = null;
        }
        if (this.connectionCheckTimeout) {
          clearTimeout(this.connectionCheckTimeout);
          this.connectionCheckTimeout = null;
        }
        
        // Remove event listeners
        window.removeEventListener('resize', this.resizeHandler);
        window.removeEventListener('orientationchange', this.orientationHandler);
        
        // Cleanup controls
        if (this.joystick) {
          this.joystick.destroy();
          this.joystick = null;
        }
        if (this.buttons.attack) {
          this.buttons.attack.destroy();
        }
        if (this.buttons.boost) {
          this.buttons.boost.destroy();
        }
        
        // Cleanup keyboard listeners if present
        if (this.keydownHandler) {
          document.removeEventListener('keydown', this.keydownHandler);
        }
        if (this.keyupHandler) {
          document.removeEventListener('keyup', this.keyupHandler);
        }
      }

      initMobileControls() {
        // Initialize joystick
        const joystickEl = document.getElementById('joystick');
        const joystickKnob = document.getElementById('joystickKnob');
        
        if (joystickEl && joystickKnob) {
          this.joystick = new JoystickController(joystickEl, joystickKnob);
        } else {
          console.error('Joystick elements not found');
        }
        
        // Initialize action buttons
        const attackBtn = document.getElementById('btnAttack');
        const boostBtn = document.getElementById('btnBoost');
        
        if (attackBtn) {
          this.buttons.attack = new ActionButton(attackBtn, 'attack');
        }
        if (boostBtn) {
          this.buttons.boost = new ActionButton(boostBtn, 'boost');
        }
        
        // Show mobile controls
        const mobileControls = document.getElementById('mobileControls');
        if (mobileControls) {
          mobileControls.style.display = 'block';
        }
        
        // Hide desktop controls
        const desktopControls = document.querySelector('.desktop-controls');
        if (desktopControls) {
          desktopControls.style.display = 'none';
        }
      }

      initDesktopControls() {
        // Hide mobile controls
        document.getElementById('mobileControls').style.display = 'none';
        
        // Keyboard controls
        this.keys = {};
        window.addEventListener('keydown', (e) => {
          this.keys[e.key.toLowerCase()] = true;
          
          if (e.key === ' ') {
            e.preventDefault();
            this.handleAction('attack', true);
          }
          if (e.key === 'Shift') {
            e.preventDefault();
            this.handleAction('boost', true);
          }
        });
        
        window.addEventListener('keyup', (e) => {
          this.keys[e.key.toLowerCase()] = false;
          
          if (e.key === ' ') {
            this.handleAction('attack', false);
          }
          if (e.key === 'Shift') {
            this.handleAction('boost', false);
          }
        });
      }

      resizeCanvas() {
        const container = this.canvas.parentElement;
        this.canvas.width = container.clientWidth;
        this.canvas.height = container.clientHeight;
        
        // Reset player position
        if (this.player) {
          this.player.x = this.canvas.width / 2;
          this.player.y = this.canvas.height / 2;
        }
      }

      reset() {
        this.player.x = this.canvas.width / 2;
        this.player.y = this.canvas.height / 2;
        this.player.vx = 0;
        this.player.vy = 0;
        
        this.enemy.x = this.canvas.width / 2;
        this.enemy.y = this.canvas.height / 4;
      }

      start() {
        this.running = true;
        this.animate();
      }

      stop() {
        this.running = false;
      }

      pause() {
        this.paused = true;
      }

      resume() {
        this.paused = false;
      }

      handleAction(action, pressed) {
        switch (action) {
          case 'attack':
            if (pressed) {
              this.attack();
            }
            break;
          case 'boost':
            this.player.boosting = pressed;
            break;
        }
      }

      attack() {
        // Attack animation/effect
        const attackRadius = 50;
        this.ctx.strokeStyle = '#22d3ee';
        this.ctx.lineWidth = 3;
        this.ctx.beginPath();
        this.ctx.arc(this.player.x, this.player.y, attackRadius, 0, Math.PI * 2);
        this.ctx.stroke();
        
        // Check collision with enemy
        const dx = this.enemy.x - this.player.x;
        const dy = this.enemy.y - this.player.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < attackRadius + this.enemy.radius) {
          this.score.you++;
          document.getElementById('scoreYou').textContent = this.score.you;
          
          // Haptic feedback
          if ('vibrate' in navigator) {
            navigator.vibrate([20, 10, 20]);
          }
        }
      }

      update(deltaTime) {
        if (this.paused) return;
        
        // Get input
        let inputX = 0;
        let inputY = 0;
        
        if (this.joystick) {
          const vector = this.joystick.getVector();
          inputX = vector.x;
          inputY = vector.y;
        } else if (this.keys) {
          // Desktop keyboard input
          if (this.keys['a'] || this.keys['arrowleft']) inputX -= 1;
          if (this.keys['d'] || this.keys['arrowright']) inputX += 1;
          if (this.keys['w'] || this.keys['arrowup']) inputY -= 1;
          if (this.keys['s'] || this.keys['arrowdown']) inputY += 1;
          
          // Normalize diagonal movement
          const magnitude = Math.sqrt(inputX * inputX + inputY * inputY);
          if (magnitude > 1) {
            inputX /= magnitude;
            inputY /= magnitude;
          }
        }
        
        if (this.isMultiplayer && this.multiplayer) {
          // Update multiplayer input
          const boost = this.buttons.boost ? this.buttons.boost.isPressed() : false;
          const attack = this.buttons.attack ? this.buttons.attack.isPressed() : false;
          
          this.multiplayer.updateLocalInput(inputX, inputY, boost, attack);
          this.multiplayer.updateLocalPosition(deltaTime);
          
          // Get synced game state
          const gameState = this.multiplayer.getGameState();
          const myRole = this.multiplayer.role;
          
          // Update local references
          if (myRole === 'host') {
            this.player = gameState.players.host;
            this.enemy = gameState.players.player;
          } else {
            this.player = gameState.players.player;
            this.enemy = gameState.players.host;
          }
          
          // Update latency display
          const latency = this.multiplayer.getLatency();
          const latencyEl = document.getElementById('connectionText');
          if (latencyEl) {
            latencyEl.textContent = `Connected (${latency}ms)`;
          }
        } else {
          // Single player movement
          const speed = this.player.boosting ? this.player.speed * 2 : this.player.speed;
          this.player.vx = inputX * speed;
          this.player.vy = inputY * speed;
          
          this.player.x += this.player.vx;
          this.player.y += this.player.vy;
          
          // Keep player in bounds
          this.player.x = Math.max(this.player.radius, Math.min(this.canvas.width - this.player.radius, this.player.x));
          this.player.y = Math.max(this.player.radius, Math.min(this.canvas.height - this.player.radius, this.player.y));
        }
        
        // Simple enemy AI
        const enemySpeed = 2;
        const dx = this.player.x - this.enemy.x;
        const dy = this.player.y - this.enemy.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist > 0) {
          this.enemy.x += (dx / dist) * enemySpeed * Math.sin(Date.now() * 0.001);
          this.enemy.y += (dy / dist) * enemySpeed * Math.cos(Date.now() * 0.001);
        }
        
        // Update timer
        const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        document.getElementById('gameTimer').textContent = 
          `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }

      render() {
        // Clear canvas
        this.ctx.fillStyle = '#0a0e27';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw grid
        this.ctx.strokeStyle = 'rgba(99, 102, 241, 0.1)';
        this.ctx.lineWidth = 1;
        const gridSize = 50;
        
        for (let x = 0; x < this.canvas.width; x += gridSize) {
          this.ctx.beginPath();
          this.ctx.moveTo(x, 0);
          this.ctx.lineTo(x, this.canvas.height);
          this.ctx.stroke();
        }
        
        for (let y = 0; y < this.canvas.height; y += gridSize) {
          this.ctx.beginPath();
          this.ctx.moveTo(0, y);
          this.ctx.lineTo(this.canvas.width, y);
          this.ctx.stroke();
        }
        
        // Draw attack effect if active
        if (this.attackEffect && this.attackEffect.alpha > 0) {
          this.ctx.strokeStyle = `rgba(34, 211, 238, ${this.attackEffect.alpha})`;
          this.ctx.lineWidth = 3;
          this.ctx.beginPath();
          this.ctx.arc(this.attackEffect.x, this.attackEffect.y, this.attackEffect.radius, 0, Math.PI * 2);
          this.ctx.stroke();
          
          // Fade out
          this.attackEffect.alpha -= 0.05;
          this.attackEffect.radius += 2;
        }
        
        // Draw enemy/other player
        if (this.enemy) {
          this.ctx.fillStyle = this.enemy.color || '#ef4444';
          if (this.enemy.boosting) {
            this.ctx.shadowBlur = 20;
            this.ctx.shadowColor = this.enemy.color || '#ef4444';
          }
          this.ctx.beginPath();
          this.ctx.arc(this.enemy.x, this.enemy.y, this.enemy.radius, 0, Math.PI * 2);
          this.ctx.fill();
          this.ctx.shadowBlur = 0;
          
          // Draw name tag for multiplayer
          if (this.isMultiplayer) {
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            this.ctx.font = '12px sans-serif';
            this.ctx.textAlign = 'center';
            const enemyName = this.multiplayer.role === 'host' ? 'Player' : 'Host';
            this.ctx.fillText(enemyName, this.enemy.x, this.enemy.y - this.enemy.radius - 10);
          }
        }
        
        // Draw player
        this.ctx.fillStyle = this.player.color || '#6366f1';
        if (this.player.boosting) {
          // Boost effect
          this.ctx.shadowBlur = 20;
          this.ctx.shadowColor = this.player.color || '#6366f1';
        }
        this.ctx.beginPath();
        this.ctx.arc(this.player.x, this.player.y, this.player.radius, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;
        
        // Draw name tag for multiplayer
        if (this.isMultiplayer) {
          this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
          this.ctx.font = '12px sans-serif';
          this.ctx.textAlign = 'center';
          this.ctx.fillText('You', this.player.x, this.player.y - this.player.radius - 10);
        }
        
        // Draw player direction indicator
        if (Math.abs(this.player.vx) > 0.1 || Math.abs(this.player.vy) > 0.1) {
          const angle = Math.atan2(this.player.vy, this.player.vx);
          const arrowLength = 30;
          const arrowX = this.player.x + Math.cos(angle) * arrowLength;
          const arrowY = this.player.y + Math.sin(angle) * arrowLength;
          
          this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
          this.ctx.lineWidth = 2;
          this.ctx.beginPath();
          this.ctx.moveTo(this.player.x, this.player.y);
          this.ctx.lineTo(arrowX, arrowY);
          this.ctx.stroke();
        }
      }

      animate(currentTime = 0) {
        if (!this.running) return;
        
        // Calculate delta time
        const deltaTime = currentTime - this.lastTime;
        this.lastTime = currentTime;
        
        // Update FPS
        this.frameCount++;
        if (currentTime - this.fpsTime > 1000) {
          this.fps = this.frameCount;
          this.frameCount = 0;
          this.fpsTime = currentTime;
          
          if (window.debugMode) {
            document.getElementById('fps').textContent = this.fps;
          }
        }
        
        // Update and render
        this.update(deltaTime);
        this.render();
        
        // Continue animation loop
        this.animationId = requestAnimationFrame(this.animate.bind(this));
      }
    }

    // Initialize game
    let gameInstance = null;
    window.debugMode = false;

    document.addEventListener('DOMContentLoaded', () => {
      const canvas = document.getElementById('gameCanvas');
      gameInstance = new MobileGame(canvas);
      window.gameInstance = gameInstance;
      
      // Update device debug info
      const deviceType = sessionStorage.getItem('deviceType') || 'auto-detected';
      const isMobile = 'ontouchstart' in window;
      document.getElementById('deviceDebug').textContent = `${deviceType} (${isMobile ? 'touch' : 'no-touch'})`;
    });

    // Global functions
    window.togglePause = function() {
      const pauseMenu = document.getElementById('pauseMenu');
      if (pauseMenu.classList.contains('active')) {
        resumeGame();
      } else {
        pauseMenu.classList.add('active');
        if (gameInstance) gameInstance.pause();
      }
    };

    window.resumeGame = function() {
      document.getElementById('pauseMenu').classList.remove('active');
      if (gameInstance) gameInstance.resume();
    };

    window.toggleDebug = function() {
      window.debugMode = !window.debugMode;
      document.getElementById('debugInfo').classList.toggle('active');
    };

    window.exitGame = function() {
      if (confirm('Exit to main menu?')) {
        window.location.href = 'menu.html';
      }
    };

    // Handle connection status
    const updateConnectionStatus = () => {
      const isConnected = sessionStorage.getItem('p2pConnected') === 'true';
      const dot = document.getElementById('connectionDot');
      const text = document.getElementById('connectionText');
      
      if (isConnected) {
        dot.classList.remove('disconnected');
        text.textContent = 'Connected';
      } else {
        dot.classList.add('disconnected');
        text.textContent = sessionStorage.getItem('gameMode') === 'solo' ? 'Solo' : 'Offline';
      }
    };

    updateConnectionStatus();
    setInterval(updateConnectionStatus, 5000);

    // Prevent default touch behaviors
    document.addEventListener('touchmove', (e) => {
      if (e.target.closest('.mobile-controls') || e.target === document.getElementById('gameCanvas')) {
        e.preventDefault();
      }
    }, { passive: false });

    // Handle visibility change
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && gameInstance && !gameInstance.paused) {
        togglePause();
      }
    });
  </script>
</body>
</html>